\section{Network Device}\label{sec:Device Types / Network Device}

The virtio network device is a virtual network interface controller.
It consists of a virtual Ethernet link which connects the device
to the Ethernet network. The device has transmit and receive
queues. The driver adds empty buffers to the receive virtqueue.
The device receives incoming packets from the link; the device
places these incoming packets in the receive virtqueue buffers.
The driver adds outgoing packets to the transmit virtqueue. The device
removes these packets from the transmit virtqueue and sends them to
the link. The device may have a control virtqueue. The driver
uses the control virtqueue to dynamically manipulate various
features of the initialized device.

\subsection{Device ID}\label{sec:Device Types / Network Device / Device ID}

 1

\subsection{Virtqueues}\label{sec:Device Types / Network Device / Virtqueues}

\begin{description}
\item[0] receiveq1
\item[1] transmitq1
\item[\ldots]
\item[2(N-1)] receiveqN
\item[2(N-1)+1] transmitqN
\item[2N] controlq
\end{description}

 N=1 if neither VIRTIO_NET_F_MQ nor VIRTIO_NET_F_RSS are negotiated, otherwise N is set by
 \field{max_virtqueue_pairs}.

controlq is optional; it only exists if VIRTIO_NET_F_CTRL_VQ is
negotiated.

\subsection{Feature bits}\label{sec:Device Types / Network Device / Feature bits}

\begin{description}
\item[VIRTIO_NET_F_CSUM (0)] Device handles packets with partial checksum offload.

\item[VIRTIO_NET_F_GUEST_CSUM (1)] Driver handles packets with partial checksum.

\item[VIRTIO_NET_F_CTRL_GUEST_OFFLOADS (2)] Control channel offloads
        reconfiguration support.

\item[VIRTIO_NET_F_MTU(3)] Device maximum MTU reporting is supported. If
    offered by the device, device advises driver about the value of
    its maximum MTU. If negotiated, the driver uses \field{mtu} as
    the maximum MTU value.

\item[VIRTIO_NET_F_MAC (5)] Device has given MAC address.

\item[VIRTIO_NET_F_GUEST_TSO4 (7)] Driver can receive TSOv4.

\item[VIRTIO_NET_F_GUEST_TSO6 (8)] Driver can receive TSOv6.

\item[VIRTIO_NET_F_GUEST_ECN (9)] Driver can receive TSO with ECN.

\item[VIRTIO_NET_F_GUEST_UFO (10)] Driver can receive UFO.

\item[VIRTIO_NET_F_HOST_TSO4 (11)] Device can receive TSOv4.

\item[VIRTIO_NET_F_HOST_TSO6 (12)] Device can receive TSOv6.

\item[VIRTIO_NET_F_HOST_ECN (13)] Device can receive TSO with ECN.

\item[VIRTIO_NET_F_HOST_UFO (14)] Device can receive UFO.

\item[VIRTIO_NET_F_MRG_RXBUF (15)] Driver can merge receive buffers.

\item[VIRTIO_NET_F_STATUS (16)] Configuration status field is
    available.

\item[VIRTIO_NET_F_CTRL_VQ (17)] Control channel is available.

\item[VIRTIO_NET_F_CTRL_RX (18)] Control channel RX mode support.

\item[VIRTIO_NET_F_CTRL_VLAN (19)] Control channel VLAN filtering.

\item[VIRTIO_NET_F_CTRL_RX_EXTRA (20)]	Control channel RX extra mode support.

\item[VIRTIO_NET_F_GUEST_ANNOUNCE(21)] Driver can send gratuitous
    packets.

\item[VIRTIO_NET_F_MQ(22)] Device supports multiqueue with automatic
    receive steering.

\item[VIRTIO_NET_F_CTRL_MAC_ADDR(23)] Set MAC address through control
    channel.

\item[VIRTIO_NET_F_DEVICE_STATS(50)] Device can provide device-level statistics
    to the driver through the control virtqueue.

\item[VIRTIO_NET_F_HASH_TUNNEL(51)] Device supports inner header hash for encapsulated packets.

\item[VIRTIO_NET_F_VQ_NOTF_COAL(52)] Device supports virtqueue notification coalescing.

\item[VIRTIO_NET_F_NOTF_COAL(53)] Device supports notifications coalescing.

\item[VIRTIO_NET_F_GUEST_USO4 (54)] Driver can receive USOv4 packets.

\item[VIRTIO_NET_F_GUEST_USO6 (55)] Driver can receive USOv6 packets.

\item[VIRTIO_NET_F_HOST_USO (56)] Device can receive USO packets. Unlike UFO
 (fragmenting the packet) the USO splits large UDP packet
 to several segments when each of these smaller packets has UDP header.

\item[VIRTIO_NET_F_HASH_REPORT(57)] Device can report per-packet hash
    value and a type of calculated hash.

\item[VIRTIO_NET_F_GUEST_HDRLEN(59)] Driver can provide the exact \field{hdr_len}
    value. Device benefits from knowing the exact header length.

\item[VIRTIO_NET_F_RSS(60)] Device supports RSS (receive-side scaling)
    with Toeplitz hash calculation and configurable hash
    parameters for receive steering.

\item[VIRTIO_NET_F_RSC_EXT(61)] Device can process duplicated ACKs
    and report number of coalesced segments and duplicated ACKs.

\item[VIRTIO_NET_F_STANDBY(62)] Device may act as a standby for a primary
    device with the same MAC address.

\item[VIRTIO_NET_F_SPEED_DUPLEX(63)] Device reports speed and duplex.

\item[VIRTIO_NET_F_RSS_CONTEXT(64)] Device supports multiple RSS contexts.
\end{description}

\subsubsection{Feature bit requirements}\label{sec:Device Types / Network Device / Feature bits / Feature bit requirements}

Some networking feature bits require other networking feature bits
(see \ref{drivernormative:Basic Facilities of a Virtio Device / Feature Bits}):

\begin{description}
\item[VIRTIO_NET_F_GUEST_TSO4] Requires VIRTIO_NET_F_GUEST_CSUM.
\item[VIRTIO_NET_F_GUEST_TSO6] Requires VIRTIO_NET_F_GUEST_CSUM.
\item[VIRTIO_NET_F_GUEST_ECN] Requires VIRTIO_NET_F_GUEST_TSO4 or VIRTIO_NET_F_GUEST_TSO6.
\item[VIRTIO_NET_F_GUEST_UFO] Requires VIRTIO_NET_F_GUEST_CSUM.
\item[VIRTIO_NET_F_GUEST_USO4] Requires VIRTIO_NET_F_GUEST_CSUM.
\item[VIRTIO_NET_F_GUEST_USO6] Requires VIRTIO_NET_F_GUEST_CSUM.

\item[VIRTIO_NET_F_HOST_TSO4] Requires VIRTIO_NET_F_CSUM.
\item[VIRTIO_NET_F_HOST_TSO6] Requires VIRTIO_NET_F_CSUM.
\item[VIRTIO_NET_F_HOST_ECN] Requires VIRTIO_NET_F_HOST_TSO4 or VIRTIO_NET_F_HOST_TSO6.
\item[VIRTIO_NET_F_HOST_UFO] Requires VIRTIO_NET_F_CSUM.
\item[VIRTIO_NET_F_HOST_USO] Requires VIRTIO_NET_F_CSUM.

\item[VIRTIO_NET_F_CTRL_RX] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_CTRL_VLAN] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_GUEST_ANNOUNCE] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_MQ] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_CTRL_MAC_ADDR] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_NOTF_COAL] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_RSC_EXT] Requires VIRTIO_NET_F_HOST_TSO4 or VIRTIO_NET_F_HOST_TSO6.
\item[VIRTIO_NET_F_RSS] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_VQ_NOTF_COAL] Requires VIRTIO_NET_F_CTRL_VQ.
\item[VIRTIO_NET_F_HASH_TUNNEL] Requires VIRTIO_NET_F_CTRL_VQ along with VIRTIO_NET_F_RSS or VIRTIO_NET_F_HASH_REPORT.
\item[VIRTIO_NET_F_RSS_CONTEXT] Requires VIRTIO_NET_F_CTRL_VQ and VIRTIO_NET_F_RSS.
\end{description}

\subsubsection{Legacy Interface: Feature bits}\label{sec:Device Types / Network Device / Feature bits / Legacy Interface: Feature bits}
\begin{description}
\item[VIRTIO_NET_F_GSO (6)] Device handles packets with any GSO type. This was supposed to indicate segmentation offload support, but
upon further investigation it became clear that multiple bits were needed.
\item[VIRTIO_NET_F_GUEST_RSC4 (41)] Device coalesces TCPIP v4 packets. This was implemented by hypervisor patch for certification
purposes and current Windows driver depends on it. It will not function if virtio-net device reports this feature.
\item[VIRTIO_NET_F_GUEST_RSC6 (42)] Device coalesces TCPIP v6 packets. Similar to VIRTIO_NET_F_GUEST_RSC4.
\end{description}

\subsection{Device configuration layout}\label{sec:Device Types / Network Device / Device configuration layout}
\label{sec:Device Types / Block Device / Feature bits / Device configuration layout}

The network device has the following device configuration layout.
All of the device configuration fields are read-only for the driver.

\begin{lstlisting}
struct virtio_net_config {
        u8 mac[6];
        le16 status;
        le16 max_virtqueue_pairs;
        le16 mtu;
        le32 speed;
        u8 duplex;
        u8 rss_max_key_size;
        le16 rss_max_indirection_table_length;
        le32 supported_hash_types;
        le32 supported_tunnel_types;
};
\end{lstlisting}

The \field{mac} address field always exists (although it is only
valid if VIRTIO_NET_F_MAC is set).

The \field{status} only exists if VIRTIO_NET_F_STATUS is set.
Two bits are currently defined for the status field: VIRTIO_NET_S_LINK_UP
and VIRTIO_NET_S_ANNOUNCE.

\begin{lstlisting}
#define VIRTIO_NET_S_LINK_UP     1
#define VIRTIO_NET_S_ANNOUNCE    2
\end{lstlisting}

The following field, \field{max_virtqueue_pairs} only exists if
VIRTIO_NET_F_MQ or VIRTIO_NET_F_RSS is set. This field specifies the maximum number
of each of transmit and receive virtqueues (receiveq1\ldots receiveqN
and transmitq1\ldots transmitqN respectively) that can be configured once at least one of these features
is negotiated.

The following field, \field{mtu} only exists if VIRTIO_NET_F_MTU
is set. This field specifies the maximum MTU for the driver to
use.

The following two fields, \field{speed} and \field{duplex}, only
exist if VIRTIO_NET_F_SPEED_DUPLEX is set.

\field{speed} contains the device speed, in units of 1 MBit per
second, 0 to 0x7fffffff, or 0xffffffff for unknown speed.

\field{duplex} has the values of 0x01 for full duplex, 0x00 for
half duplex and 0xff for unknown duplex state.

Both \field{speed} and \field{duplex} can change, thus the driver
is expected to re-read these values after receiving a
configuration change notification.

The following field, \field{rss_max_key_size} only exists if VIRTIO_NET_F_RSS or VIRTIO_NET_F_HASH_REPORT is set.
It specifies the maximum supported length of RSS key in bytes.

The following field, \field{rss_max_indirection_table_length} only exists if VIRTIO_NET_F_RSS is set.
It specifies the maximum number of 16-bit entries in RSS indirection table.

The next field, \field{supported_hash_types} only exists if the device supports hash calculation,
i.e. if VIRTIO_NET_F_RSS or VIRTIO_NET_F_HASH_REPORT is set.

Field \field{supported_hash_types} contains the bitmask of supported hash types.
See \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Supported/enabled hash types} for details of supported hash types.

Field \field{supported_tunnel_types} only exists if the device supports inner header hash, i.e. if VIRTIO_NET_F_HASH_TUNNEL is set.

Field \field{supported_tunnel_types} contains the bitmask of encapsulation types supported by the device for inner header hash.
Encapsulation types are defined in \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets /
Hash calculation for incoming packets / Encapsulation types supported/enabled for inner header hash}.

\devicenormative{\subsubsection}{Device configuration layout}{Device Types / Network Device / Device configuration layout}

The device MUST set \field{max_virtqueue_pairs} to between 1 and 0x8000 inclusive,
if it offers VIRTIO_NET_F_MQ.

The device MUST set \field{mtu} to between 68 and 65535 inclusive,
if it offers VIRTIO_NET_F_MTU.

The device SHOULD set \field{mtu} to at least 1280, if it offers
VIRTIO_NET_F_MTU.

The device MUST NOT modify \field{mtu} once it has been set.

The device MUST NOT pass received packets that exceed \field{mtu} (plus low
level ethernet header length) size with \field{gso_type} NONE or ECN
after VIRTIO_NET_F_MTU has been successfully negotiated.

The device MUST forward transmitted packets of up to \field{mtu} (plus low
level ethernet header length) size with \field{gso_type} NONE or ECN, and do
so without fragmentation, after VIRTIO_NET_F_MTU has been successfully
negotiated.

The device MUST set \field{rss_max_key_size} to at least 40, if it offers
VIRTIO_NET_F_RSS or VIRTIO_NET_F_HASH_REPORT.

The device MUST set \field{rss_max_indirection_table_length} to at least 128, if it offers
VIRTIO_NET_F_RSS.

If the driver negotiates the VIRTIO_NET_F_STANDBY feature, the device MAY act
as a standby device for a primary device with the same MAC address.

If VIRTIO_NET_F_SPEED_DUPLEX has been negotiated, \field{speed}
MUST contain the device speed, in units of 1 MBit per second, 0 to
0x7ffffffff, or 0xfffffffff for unknown.

If VIRTIO_NET_F_SPEED_DUPLEX has been negotiated, \field{duplex}
MUST have the values of 0x00 for full duplex, 0x01 for half
duplex, or 0xff for unknown.

If VIRTIO_NET_F_SPEED_DUPLEX and VIRTIO_NET_F_STATUS have both
been negotiated, the device SHOULD NOT change the \field{speed} and
\field{duplex} fields as long as VIRTIO_NET_S_LINK_UP is set in
the \field{status}.

The device SHOULD NOT offer VIRTIO_NET_F_HASH_REPORT if it
does not offer VIRTIO_NET_F_CTRL_VQ.

The device SHOULD NOT offer VIRTIO_NET_F_CTRL_RX_EXTRA if it
does not offer VIRTIO_NET_F_CTRL_VQ.

\drivernormative{\subsubsection}{Device configuration layout}{Device Types / Network Device / Device configuration layout}

The driver MUST NOT write to any of the device configuration fields.

A driver SHOULD negotiate VIRTIO_NET_F_MAC if the device offers it.
If the driver negotiates the VIRTIO_NET_F_MAC feature, the driver MUST set
the physical address of the NIC to \field{mac}.  Otherwise, it SHOULD
use a locally-administered MAC address (see \hyperref[intro:IEEE 802]{IEEE 802},
``9.2 48-bit universal LAN MAC addresses'').

If the driver does not negotiate the VIRTIO_NET_F_STATUS feature, it SHOULD
assume the link is active, otherwise it SHOULD read the link status from
the bottom bit of \field{status}.

A driver SHOULD negotiate VIRTIO_NET_F_MTU if the device offers it.

If the driver negotiates VIRTIO_NET_F_MTU, it MUST supply enough receive
buffers to receive at least one receive packet of size \field{mtu} (plus low
level ethernet header length) with \field{gso_type} NONE or ECN.

If the driver negotiates VIRTIO_NET_F_MTU, it MUST NOT transmit packets of
size exceeding the value of \field{mtu} (plus low level ethernet header length)
with \field{gso_type} NONE or ECN.

A driver SHOULD negotiate the VIRTIO_NET_F_STANDBY feature if the device offers it.

If VIRTIO_NET_F_SPEED_DUPLEX has been negotiated,
the driver MUST treat any value of \field{speed} above
0x7fffffff as well as any value of \field{duplex} not
matching 0x00 or 0x01 as an unknown value.

If VIRTIO_NET_F_SPEED_DUPLEX has been negotiated, the driver
SHOULD re-read \field{speed} and \field{duplex} after a
configuration change notification.

A driver SHOULD NOT negotiate VIRTIO_NET_F_HASH_REPORT if it
does not negotiate VIRTIO_NET_F_CTRL_VQ.

A driver SHOULD NOT negotiate VIRTIO_NET_F_CTRL_RX_EXTRA if it
does not negotiate VIRTIO_NET_F_CTRL_VQ.

\subsubsection{Legacy Interface: Device configuration layout}\label{sec:Device Types / Network Device / Device configuration layout / Legacy Interface: Device configuration layout}
\label{sec:Device Types / Block Device / Feature bits / Device configuration layout / Legacy Interface: Device configuration layout}
When using the legacy interface, transitional devices and drivers
MUST format \field{status} and
\field{max_virtqueue_pairs} in struct virtio_net_config
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.

When using the legacy interface, \field{mac} is driver-writable
which provided a way for drivers to update the MAC without
negotiating VIRTIO_NET_F_CTRL_MAC_ADDR.

\subsection{Device Initialization}\label{sec:Device Types / Network Device / Device Initialization}

A driver would perform a typical initialization routine like so:

\begin{enumerate}
\item Identify and initialize the receive and
  transmission virtqueues, up to N of each kind. If
  VIRTIO_NET_F_MQ feature bit is negotiated,
  N=\field{max_virtqueue_pairs}, otherwise identify N=1.

\item If the VIRTIO_NET_F_CTRL_VQ feature bit is negotiated,
  identify the control virtqueue.

\item Fill the receive queues with buffers: see \ref{sec:Device Types / Network Device / Device Operation / Setting Up Receive Buffers}.

\item Even with VIRTIO_NET_F_MQ, only receiveq1, transmitq1 and
  controlq are used by default.  The driver would send the
  VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command specifying the
  number of the transmit and receive queues to use.

\item If the VIRTIO_NET_F_MAC feature bit is set, the configuration
  space \field{mac} entry indicates the ``physical'' address of the
  device, otherwise the driver would typically generate a random
  local MAC address.

\item If the VIRTIO_NET_F_STATUS feature bit is negotiated, the link
  status comes from the bottom bit of \field{status}.
  Otherwise, the driver assumes it's active.

\item A performant driver would indicate that it will generate checksumless
  packets by negotiating the VIRTIO_NET_F_CSUM feature.

\item If that feature is negotiated, a driver can use TCP segmentation or UDP
  segmentation/fragmentation offload by negotiating the VIRTIO_NET_F_HOST_TSO4 (IPv4
  TCP), VIRTIO_NET_F_HOST_TSO6 (IPv6 TCP), VIRTIO_NET_F_HOST_UFO
  (UDP fragmentation) and VIRTIO_NET_F_HOST_USO (UDP segmentation) features.

\item The converse features are also available: a driver can save
  the virtual device some work by negotiating these features.\note{For example, a network packet transported between two guests on
the same system might not need checksumming at all, nor segmentation,
if both guests are amenable.}
   The VIRTIO_NET_F_GUEST_CSUM feature indicates that partially
  checksummed packets can be received, and if it can do that then
  the VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6,
  VIRTIO_NET_F_GUEST_UFO, VIRTIO_NET_F_GUEST_ECN, VIRTIO_NET_F_GUEST_USO4
  and VIRTIO_NET_F_GUEST_USO6 are the input equivalents of the features described above.
  See \ref{sec:Device Types / Network Device / Device Operation /
Setting Up Receive Buffers}~\nameref{sec:Device Types / Network
Device / Device Operation / Setting Up Receive Buffers} and
\ref{sec:Device Types / Network Device / Device Operation /
Processing of Incoming Packets}~\nameref{sec:Device Types /
Network Device / Device Operation / Processing of Incoming Packets} below.
\end{enumerate}

A truly minimal driver would only accept VIRTIO_NET_F_MAC and ignore
everything else.

\subsection{Device and driver capabilities}\label{sec:Device Types / Network Device / Device and driver capabilities}

The network device has the following capabilities.

\begin{tabularx}{\textwidth}{ |l||l|X| }
\hline
Identifier & Name & Description \\
\hline \hline
0x0800 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-RESOURCE-CAP]{VIRTIO_NET_FF_RESOURCE_CAP} & Flow filter resource capability \\
\hline
0x0801 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP]{VIRTIO_NET_FF_SELECTOR_CAP} & Flow filter classifier capability \\
\hline
0x0802 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-ACTION-CAP]{VIRTIO_NET_FF_ACTION_CAP} & Flow filter action capability \\
\hline
\end{tabularx}

\subsection{Device resource objects}\label{sec:Device Types / Network Device / Device resource objects}

The network device has the following resource objects.

\begin{tabularx}{\textwidth}{ |l||l|X| }
\hline
type & Name & Description \\
\hline \hline
0x0200 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-GROUP]{VIRTIO_NET_RESOURCE_OBJ_FF_GROUP} & Flow filter group resource object \\
\hline
0x0201 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-CLASSIFIER]{VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER} & Flow filter mask object \\
\hline
0x0202 & \hyperref[par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-RULE]{VIRTIO_NET_RESOURCE_OBJ_FF_RULE} & Flow filter rule object \\
\hline
\end{tabularx}

\subsection{Device parts}\label{sec:Device Types / Network Device / Device parts}

Network device parts represent the configuration done by the driver using control
virtqueue commands. Network device part is in the format of
\field{struct virtio_dev_part}.

\begin{tabularx}{\textwidth}{ |l||l|X| }
\hline
Type & Name & Description \\
\hline \hline
0x200 & VIRTIO_NET_DEV_PART_CVQ_CFG_PART & Represents device configuration done through a control virtqueue command, see \ref{sec:Device Types / Network Device / Device parts / VIRTIO-NET-DEV-PART-CVQ-CFG-PART} \\
\hline
0x201 - 0x5FF & - & reserved for future \\
\hline
\hline
\end{tabularx}

\subsubsection{VIRTIO_NET_DEV_PART_CVQ_CFG_PART}\label{sec:Device Types / Network Device / Device parts / VIRTIO-NET-DEV-PART-CVQ-CFG-PART}

For VIRTIO_NET_DEV_PART_CVQ_CFG_PART, \field{part_type} is set to 0x200. The
VIRTIO_NET_DEV_PART_CVQ_CFG_PART part indicates configuration performed by the
driver using a control virtqueue command.

\begin{lstlisting}
struct virtio_net_dev_part_cvq_selector {
        u8 class;
        u8 command;
        u8 reserved[6];
};
\end{lstlisting}

There is one device part of type VIRTIO_NET_DEV_PART_CVQ_CFG_PART for each
individual configuration. Each part is identified by a unique selector value.
The selector, \field{device_type_raw}, is in the format
\field{struct virtio_net_dev_part_cvq_selector}.

The selector consists of two fields: \field{class} and \field{command}. These
fields correspond to the \field{class} and \field{command} defined in
\field{struct virtio_net_ctrl}, as described in the relevant sections of
\ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue}.

The value corresponding to each part’s selector follows the same format as the
respective \field{command-specific-data} described in the relevant sections of
\ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue}.

For example, when the \field{class} is VIRTIO_NET_CTRL_MAC, the \field{command}
can be either VIRTIO_NET_CTRL_MAC_TABLE_SET or VIRTIO_NET_CTRL_MAC_ADDR_SET;
when \field{command} is set to VIRTIO_NET_CTRL_MAC_TABLE_SET, \field{value}
is in the format of \field{struct virtio_net_ctrl_mac}.

Supported selectors are listed in the table:

\begin{tabularx}{\textwidth}{ |l|X| }
\hline
Class selector & Command selector \\
\hline \hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_PROMISC \\
\hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_ALLMULTI \\
\hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_ALLUNI \\
\hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_NOMULTI \\
\hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_NOUNI \\
\hline
VIRTIO_NET_CTRL_RX & VIRTIO_NET_CTRL_RX_NOBCAST \\
\hline
VIRTIO_NET_CTRL_MAC & VIRTIO_NET_CTRL_MAC_TABLE_SET \\
\hline
VIRTIO_NET_CTRL_MAC & VIRTIO_NET_CTRL_MAC_ADDR_SET \\
\hline
VIRTIO_NET_CTRL_VLAN & VIRTIO_NET_CTRL_VLAN_ADD \\
\hline
VIRTIO_NET_CTRL_ANNOUNCE & VIRTIO_NET_CTRL_ANNOUNCE_ACK \\
\hline
VIRTIO_NET_CTRL_MQ & VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET \\
\hline
VIRTIO_NET_CTRL_MQ & VIRTIO_NET_CTRL_MQ_RSS_CONFIG \\
\hline
VIRTIO_NET_CTRL_MQ & VIRTIO_NET_CTRL_MQ_HASH_CONFIG \\
\hline
\hline
\end{tabularx}

For command selector VIRTIO_NET_CTRL_VLAN_ADD, device part consists of a whole
VLAN table.

\field{reserved} is reserved and set to zero.

\subsection{Device Operation}\label{sec:Device Types / Network Device / Device Operation}

Packets are transmitted by placing them in the
transmitq1\ldots transmitqN, and buffers for incoming packets are
placed in the receiveq1\ldots receiveqN. In each case, the packet
itself is preceded by a header:

\begin{lstlisting}
struct virtio_net_hdr {
#define VIRTIO_NET_HDR_F_NEEDS_CSUM    1
#define VIRTIO_NET_HDR_F_DATA_VALID    2
#define VIRTIO_NET_HDR_F_RSC_INFO      4
        u8 flags;
#define VIRTIO_NET_HDR_GSO_NONE        0
#define VIRTIO_NET_HDR_GSO_TCPV4       1
#define VIRTIO_NET_HDR_GSO_UDP         3
#define VIRTIO_NET_HDR_GSO_TCPV6       4
#define VIRTIO_NET_HDR_GSO_UDP_L4      5
#define VIRTIO_NET_HDR_GSO_ECN      0x80
        u8 gso_type;
        le16 hdr_len;
        le16 gso_size;
        le16 csum_start;
        le16 csum_offset;
        le16 num_buffers;
        le32 hash_value;        (Only if VIRTIO_NET_F_HASH_REPORT negotiated)
        le16 hash_report;       (Only if VIRTIO_NET_F_HASH_REPORT negotiated)
        le16 padding_reserved;  (Only if VIRTIO_NET_F_HASH_REPORT negotiated)
};
\end{lstlisting}

The controlq is used to control various device features described further in
section \ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue}.

\subsubsection{Legacy Interface: Device Operation}\label{sec:Device Types / Network Device / Device Operation / Legacy Interface: Device Operation}
When using the legacy interface, transitional devices and drivers
MUST format the fields in \field{struct virtio_net_hdr}
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.

The legacy driver only presented \field{num_buffers} in the \field{struct virtio_net_hdr}
when VIRTIO_NET_F_MRG_RXBUF was negotiated; without that feature the
structure was 2 bytes shorter.

When using the legacy interface, the driver SHOULD ignore the
used length for the transmit queues
and the controlq queue.
\begin{note}
Historically, some devices put
the total descriptor length there, even though no data was
actually written.
\end{note}

\subsubsection{Packet Transmission}\label{sec:Device Types / Network Device / Device Operation / Packet Transmission}

Transmitting a single packet is simple, but varies depending on
the different features the driver negotiated.

\begin{enumerate}
\item The driver can send a completely checksummed packet.  In this case,
  \field{flags} will be zero, and \field{gso_type} will be VIRTIO_NET_HDR_GSO_NONE.

\item If the driver negotiated VIRTIO_NET_F_CSUM, it can skip
  checksumming the packet:
  \begin{itemize}
  \item \field{flags} has the VIRTIO_NET_HDR_F_NEEDS_CSUM set,

  \item \field{csum_start} is set to the offset within the packet to begin checksumming,
    and

  \item \field{csum_offset} indicates how many bytes after the csum_start the
    new (16 bit ones' complement) checksum is placed by the device.

  \item The TCP checksum field in the packet is set to the sum
    of the TCP pseudo header, so that replacing it by the ones'
    complement checksum of the TCP header and body will give the
    correct result.
  \end{itemize}

\begin{note}
For example, consider a partially checksummed TCP (IPv4) packet.
It will have a 14 byte ethernet header and 20 byte IP header
followed by the TCP header (with the TCP checksum field 16 bytes
into that header). \field{csum_start} will be 14+20 = 34 (the TCP
checksum includes the header), and \field{csum_offset} will be 16.
\end{note}

\item If the driver negotiated
  VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO, and the packet requires
  TCP segmentation, UDP segmentation or fragmentation, then \field{gso_type}
  is set to VIRTIO_NET_HDR_GSO_TCPV4, TCPV6, UDP_L4 or UDP.
  (Otherwise, it is set to VIRTIO_NET_HDR_GSO_NONE). In this
  case, packets larger than 1514 bytes can be transmitted: the
  metadata indicates how to replicate the packet header to cut it
  into smaller packets. The other gso fields are set:

  \begin{itemize}
  \item If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated,
    \field{hdr_len} indicates the header length that needs to be replicated
    for each packet. It's the number of bytes from the beginning of the packet
    to the beginning of the transport payload.
    Otherwise, if the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated,
    \field{hdr_len} is a hint to the device as to how much of the header
    needs to be kept to copy into each packet, usually set to the
    length of the headers, including the transport header\footnote{Due to various bugs in implementations, this field is not useful
as a guarantee of the transport header size.
}.

  \begin{note}
  Some devices benefit from knowledge of the exact header length.
  \end{note}

  \item \field{gso_size} is the maximum size of each packet beyond that
    header (ie. MSS).

  \item If the driver negotiated the VIRTIO_NET_F_HOST_ECN feature,
    the VIRTIO_NET_HDR_GSO_ECN bit in \field{gso_type}
    indicates that the TCP packet has the ECN bit set\footnote{This case is not handled by some older hardware, so is called out
specifically in the protocol.}.
   \end{itemize}

\item \field{num_buffers} is set to zero.  This field is unused on transmitted packets.

\item The header and packet are added as one output descriptor to the
  transmitq, and the device is notified of the new entry
  (see \ref{sec:Device Types / Network Device / Device Initialization}~\nameref{sec:Device Types / Network Device / Device Initialization}).
\end{enumerate}

\drivernormative{\paragraph}{Packet Transmission}{Device Types / Network Device / Device Operation / Packet Transmission}

For the transmit packet buffer, the driver MUST use the size of the
structure \field{struct virtio_net_hdr} same as the receive packet buffer.

The driver MUST set \field{num_buffers} to zero.

If VIRTIO_NET_F_CSUM is not negotiated, the driver MUST set
\field{flags} to zero and SHOULD supply a fully checksummed
packet to the device.

If VIRTIO_NET_F_HOST_TSO4 is negotiated, the driver MAY set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV4 to request TCPv4
segmentation, otherwise the driver MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV4.

If VIRTIO_NET_F_HOST_TSO6 is negotiated, the driver MAY set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV6 to request TCPv6
segmentation, otherwise the driver MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV6.

If VIRTIO_NET_F_HOST_UFO is negotiated, the driver MAY set
\field{gso_type} to VIRTIO_NET_HDR_GSO_UDP to request UDP
fragmentation, otherwise the driver MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_UDP.

If VIRTIO_NET_F_HOST_USO is negotiated, the driver MAY set
\field{gso_type} to VIRTIO_NET_HDR_GSO_UDP_L4 to request UDP
segmentation, otherwise the driver MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_UDP_L4.

The driver SHOULD NOT send to the device TCP packets requiring segmentation offload
which have the Explicit Congestion Notification bit set, unless the
VIRTIO_NET_F_HOST_ECN feature is negotiated, in which case the
driver MUST set the VIRTIO_NET_HDR_GSO_ECN bit in
\field{gso_type}.

If the VIRTIO_NET_F_CSUM feature has been negotiated, the
driver MAY set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in
\field{flags}, if so:
\begin{enumerate}
\item the driver MUST validate the packet checksum at
	offset \field{csum_offset} from \field{csum_start} as well as all
	preceding offsets;
\item the driver MUST set the packet checksum stored in the
	buffer to the TCP/UDP pseudo header;
\item the driver MUST set \field{csum_start} and
	\field{csum_offset} such that calculating a ones'
	complement checksum from \field{csum_start} up until the end of
	the packet and storing the result at offset \field{csum_offset}
	from  \field{csum_start} will result in a fully checksummed
	packet;
\end{enumerate}

If none of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have
been negotiated, the driver MUST set \field{gso_type} to
VIRTIO_NET_HDR_GSO_NONE.

If \field{gso_type} differs from VIRTIO_NET_HDR_GSO_NONE, then
the driver MUST also set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in
\field{flags} and MUST set \field{gso_size} to indicate the
desired MSS.

If one of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have
been negotiated:
\begin{itemize}
\item If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated,
	and \field{gso_type} differs from VIRTIO_NET_HDR_GSO_NONE,
	the driver MUST set \field{hdr_len} to a value equal to the length
	of the headers, including the transport header.

\item If the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated,
	or \field{gso_type} is VIRTIO_NET_HDR_GSO_NONE,
	the driver SHOULD set \field{hdr_len} to a value
	not less than the length of the headers, including the transport
	header.
\end{itemize}

The driver SHOULD accept the VIRTIO_NET_F_GUEST_HDRLEN feature if it has
been offered, and if it's able to provide the exact header length.

The driver MUST NOT set the VIRTIO_NET_HDR_F_DATA_VALID and
VIRTIO_NET_HDR_F_RSC_INFO bits in \field{flags}.

\devicenormative{\paragraph}{Packet Transmission}{Device Types / Network Device / Device Operation / Packet Transmission}
The device MUST ignore \field{flag} bits that it does not recognize.

If VIRTIO_NET_HDR_F_NEEDS_CSUM bit in \field{flags} is not set, the
device MUST NOT use the \field{csum_start} and \field{csum_offset}.

If one of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have
been negotiated:
\begin{itemize}
\item If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated,
	and \field{gso_type} differs from VIRTIO_NET_HDR_GSO_NONE,
	the device MAY use \field{hdr_len} as the transport header size.

	\begin{note}
	Caution should be taken by the implementation so as to prevent
	a malicious driver from attacking the device by setting an incorrect hdr_len.
	\end{note}

\item If the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated,
	or \field{gso_type} is VIRTIO_NET_HDR_GSO_NONE,
	the device MAY use \field{hdr_len} only as a hint about the
	transport header size.
	The device MUST NOT rely on \field{hdr_len} to be correct.

	\begin{note}
	This is due to various bugs in implementations.
	\end{note}
\end{itemize}

If VIRTIO_NET_HDR_F_NEEDS_CSUM is not set, the device MUST NOT
rely on the packet checksum being correct.
\paragraph{Packet Transmission Interrupt}\label{sec:Device Types / Network Device / Device Operation / Packet Transmission / Packet Transmission Interrupt}

Often a driver will suppress transmission virtqueue interrupts
and check for used packets in the transmit path of following
packets.

The normal behavior in this interrupt handler is to retrieve
used buffers from the virtqueue and free the corresponding
headers and packets.

\subsubsection{Setting Up Receive Buffers}\label{sec:Device Types / Network Device / Device Operation / Setting Up Receive Buffers}

It is generally a good idea to keep the receive virtqueue as
fully populated as possible: if it runs out, network performance
will suffer.

If the VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6,
VIRTIO_NET_F_GUEST_UFO, VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6
features are used, the maximum incoming packet
will be 65589 bytes long (14 bytes of Ethernet header, plus 40 bytes of
the IPv6 header, plus 65535 bytes of maximum IPv6 payload including any
extension header), otherwise 1514 bytes.
When VIRTIO_NET_F_HASH_REPORT is not negotiated, the required receive buffer
size is either 65601 or 1526 bytes accounting for 20 bytes of
\field{struct virtio_net_hdr} followed by receive packet.
When VIRTIO_NET_F_HASH_REPORT is negotiated, the required receive buffer
size is either 65609 or 1534 bytes accounting for 12 bytes of
\field{struct virtio_net_hdr} followed by receive packet.

\drivernormative{\paragraph}{Setting Up Receive Buffers}{Device Types / Network Device / Device Operation / Setting Up Receive Buffers}

\begin{itemize}
\item If VIRTIO_NET_F_MRG_RXBUF is not negotiated:
  \begin{itemize}
    \item If VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6, VIRTIO_NET_F_GUEST_UFO,
	VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6 are negotiated, the driver SHOULD populate
      the receive queue(s) with buffers of at least 65609 bytes if
      VIRTIO_NET_F_HASH_REPORT is negotiated, and of at least 65601 bytes if not.
    \item Otherwise, the driver SHOULD populate the receive queue(s)
      with buffers of at least 1534 bytes if VIRTIO_NET_F_HASH_REPORT
      is negotiated, and of at least 1526 bytes if not.
  \end{itemize}
\item If VIRTIO_NET_F_MRG_RXBUF is negotiated, each buffer MUST be at
least size of \field{struct virtio_net_hdr},
i.e. 20 bytes if VIRTIO_NET_F_HASH_REPORT is negotiated, and 12 bytes if not.
\end{itemize}

\begin{note}
Obviously each buffer can be split across multiple descriptor elements.
\end{note}

When calculating the size of \field{struct virtio_net_hdr}, the driver
MUST consider all the fields inclusive up to \field{padding_reserved},
i.e. 20 bytes if VIRTIO_NET_F_HASH_REPORT is negotiated, and 12 bytes if not.

If VIRTIO_NET_F_MQ is negotiated, each of receiveq1\ldots receiveqN
that will be used SHOULD be populated with receive buffers.

\devicenormative{\paragraph}{Setting Up Receive Buffers}{Device Types / Network Device / Device Operation / Setting Up Receive Buffers}

The device MUST set \field{num_buffers} to the number of descriptors used to
hold the incoming packet.

The device MUST use only a single descriptor if VIRTIO_NET_F_MRG_RXBUF
was not negotiated.
\begin{note}
{This means that \field{num_buffers} will always be 1
if VIRTIO_NET_F_MRG_RXBUF is not negotiated.}
\end{note}

\subsubsection{Processing of Incoming Packets}\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets}
\label{sec:Device Types / Network Device / Device Operation / Processing of Packets}%old label for latexdiff

When a packet is copied into a buffer in the receiveq, the
optimal path is to disable further used buffer notifications for the
receiveq and process packets until no more are found, then re-enable
them.

Processing incoming packets involves:

\begin{enumerate}
\item \field{num_buffers} indicates how many descriptors
  this packet is spread over (including this one): this will
  always be 1 if VIRTIO_NET_F_MRG_RXBUF was not negotiated.
  This allows receipt of large packets without having to allocate large
  buffers: a packet that does not fit in a single buffer can flow
  over to the next buffer, and so on. In this case, there will be
  at least \field{num_buffers} used buffers in the virtqueue, and the device
  chains them together to form a single packet in a way similar to
  how it would store it in a single buffer spread over multiple
  descriptors.
  The other buffers will not begin with a \field{struct virtio_net_hdr}.

\item If
  \field{num_buffers} is one, then the entire packet will be
  contained within this buffer, immediately following the struct
  virtio_net_hdr.
\item If the VIRTIO_NET_F_GUEST_CSUM feature was negotiated, the
  VIRTIO_NET_HDR_F_DATA_VALID bit in \field{flags} can be
  set: if so, device has validated the packet checksum.
  In case of multiple encapsulated protocols, one level of checksums
  has been validated.
\end{enumerate}

Additionally, VIRTIO_NET_F_GUEST_CSUM, TSO4, TSO6, UDP and ECN
features enable receive checksum, large receive offload and ECN
support which are the input equivalents of the transmit checksum,
transmit segmentation offloading and ECN features, as described
in \ref{sec:Device Types / Network Device / Device Operation /
Packet Transmission}:
\begin{enumerate}
\item If the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options were
  negotiated, then \field{gso_type} MAY be something other than
  VIRTIO_NET_HDR_GSO_NONE, and \field{gso_size} field indicates the
  desired MSS (see Packet Transmission point 2).
\item If the VIRTIO_NET_F_RSC_EXT option was negotiated (this
  implies one of VIRTIO_NET_F_GUEST_TSO4, TSO6), the
  device processes also duplicated ACK segments, reports
  number of coalesced TCP segments in \field{csum_start} field and
  number of duplicated ACK segments in \field{csum_offset} field
  and sets bit VIRTIO_NET_HDR_F_RSC_INFO in \field{flags}.
\item If the VIRTIO_NET_F_GUEST_CSUM feature was negotiated, the
  VIRTIO_NET_HDR_F_NEEDS_CSUM bit in \field{flags} can be
  set: if so, the packet checksum at offset \field{csum_offset}
  from \field{csum_start} and any preceding checksums
  have been validated.  The checksum on the packet is incomplete and
  if bit VIRTIO_NET_HDR_F_RSC_INFO is not set in \field{flags},
  then \field{csum_start} and \field{csum_offset} indicate how to calculate it
  (see Packet Transmission point 1).

\end{enumerate}

If applicable, the device calculates per-packet hash for incoming packets as
defined in \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets}.

If applicable, the device reports hash information for incoming packets as
defined in \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash reporting for incoming packets}.

\devicenormative{\paragraph}{Processing of Incoming Packets}{Device Types / Network Device / Device Operation / Processing of Incoming Packets}
\label{devicenormative:Device Types / Network Device / Device Operation / Processing of Packets}%old label for latexdiff

If VIRTIO_NET_F_MRG_RXBUF has not been negotiated, the device MUST set
\field{num_buffers} to 1.

If VIRTIO_NET_F_MRG_RXBUF has been negotiated, the device MUST set
\field{num_buffers} to indicate the number of buffers
the packet (including the header) is spread over.

If a receive packet is spread over multiple buffers, the device
MUST use all buffers but the last (i.e. the first \field{num_buffers} -
1 buffers) completely up to the full length of each buffer
supplied by the driver.

The device MUST use all buffers used by a single receive
packet together, such that at least \field{num_buffers} are
observed by driver as used.

If VIRTIO_NET_F_GUEST_CSUM is not negotiated, the device MUST set
\field{flags} to zero and SHOULD supply a fully checksummed
packet to the driver.

If VIRTIO_NET_F_GUEST_TSO4 is not negotiated, the device MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV4.

If VIRTIO_NET_F_GUEST_UDP is not negotiated, the device MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_UDP.

If VIRTIO_NET_F_GUEST_TSO6 is not negotiated, the device MUST NOT set
\field{gso_type} to VIRTIO_NET_HDR_GSO_TCPV6.

If none of VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6 have been negotiated,
the device MUST NOT set \field{gso_type} to VIRTIO_NET_HDR_GSO_UDP_L4.

The device SHOULD NOT send to the driver TCP packets requiring segmentation offload
which have the Explicit Congestion Notification bit set, unless the
VIRTIO_NET_F_GUEST_ECN feature is negotiated, in which case the
device MUST set the VIRTIO_NET_HDR_GSO_ECN bit in
\field{gso_type}.

If the VIRTIO_NET_F_GUEST_CSUM feature has been negotiated, the
device MAY set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in
\field{flags}, if so:
\begin{enumerate}
\item the device MUST validate the packet checksum at
	offset \field{csum_offset} from \field{csum_start} as well as all
	preceding offsets;
\item the device MUST set the packet checksum stored in the
	receive buffer to the TCP/UDP pseudo header;
\item the device MUST set \field{csum_start} and
	\field{csum_offset} such that calculating a ones'
	complement checksum from \field{csum_start} up until the
	end of the packet and storing the result at offset
	\field{csum_offset} from  \field{csum_start} will result in a
	fully checksummed packet;
\end{enumerate}

If none of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have
been negotiated, the device MUST set \field{gso_type} to
VIRTIO_NET_HDR_GSO_NONE.

If \field{gso_type} differs from VIRTIO_NET_HDR_GSO_NONE, then
the device MUST also set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in
\field{flags} MUST set \field{gso_size} to indicate the desired MSS.
If VIRTIO_NET_F_RSC_EXT was negotiated, the device MUST also
set VIRTIO_NET_HDR_F_RSC_INFO bit in \field{flags},
set \field{csum_start} to number of coalesced TCP segments and
set \field{csum_offset} to number of received duplicated ACK segments.

If VIRTIO_NET_F_RSC_EXT was not negotiated, the device MUST
not set VIRTIO_NET_HDR_F_RSC_INFO bit in \field{flags}.

If one of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have
been negotiated, the device SHOULD set \field{hdr_len} to a value
not less than the length of the headers, including the transport
header.

If the VIRTIO_NET_F_GUEST_CSUM feature has been negotiated, the
device MAY set the VIRTIO_NET_HDR_F_DATA_VALID bit in
\field{flags}, if so, the device MUST validate the packet
checksum (in case of multiple encapsulated protocols, one level
of checksums is validated).

\drivernormative{\paragraph}{Processing of Incoming
Packets}{Device Types / Network Device / Device Operation /
Processing of Incoming Packets}

The driver MUST ignore \field{flag} bits that it does not recognize.

If VIRTIO_NET_HDR_F_NEEDS_CSUM bit in \field{flags} is not set or
if VIRTIO_NET_HDR_F_RSC_INFO bit \field{flags} is set, the
driver MUST NOT use the \field{csum_start} and \field{csum_offset}.

If one of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have
been negotiated, the driver MAY use \field{hdr_len} only as a hint about the
transport header size.
The driver MUST NOT rely on \field{hdr_len} to be correct.
\begin{note}
This is due to various bugs in implementations.
\end{note}

If neither VIRTIO_NET_HDR_F_NEEDS_CSUM nor
VIRTIO_NET_HDR_F_DATA_VALID is set, the driver MUST NOT
rely on the packet checksum being correct.

\paragraph{Hash calculation for incoming packets}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets}

A device attempts to calculate a per-packet hash in the following cases:
\begin{itemize}
\item The feature VIRTIO_NET_F_RSS was negotiated. The device uses the hash to determine the receive virtqueue to place incoming packets.
\item The feature VIRTIO_NET_F_HASH_REPORT was negotiated. The device reports the hash value and the hash type with the packet.
\end{itemize}

If the feature VIRTIO_NET_F_RSS was negotiated:
\begin{itemize}
\item The device uses \field{hash_types} of the virtio_net_rss_config structure as 'Enabled hash types' bitmask.
\item If additionally the feature VIRTIO_NET_F_HASH_TUNNEL was negotiated, the device uses \field{enabled_tunnel_types} of the
      virtnet_hash_tunnel structure as 'Encapsulation types enabled for inner header hash' bitmask.
\item The device uses a key as defined in \field{hash_key_data} and \field{hash_key_length} of the virtio_net_rss_config structure (see
\ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) / Setting RSS parameters}).
\end{itemize}

If the feature VIRTIO_NET_F_RSS was not negotiated:
\begin{itemize}
\item The device uses \field{hash_types} of the virtio_net_hash_config structure as 'Enabled hash types' bitmask.
\item If additionally the feature VIRTIO_NET_F_HASH_TUNNEL was negotiated, the device uses \field{enabled_tunnel_types} of the
      virtnet_hash_tunnel structure as 'Encapsulation types enabled for inner header hash' bitmask.
\item The device uses a key as defined in \field{hash_key_data} and \field{hash_key_length} of the virtio_net_hash_config structure (see
\ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode / Hash calculation}).
\end{itemize}

Note that if the device offers VIRTIO_NET_F_HASH_REPORT, even if it supports only one pair of virtqueues, it MUST support
at least one of commands of VIRTIO_NET_CTRL_MQ class to configure reported hash parameters:
\begin{itemize}
\item If the device offers VIRTIO_NET_F_RSS, it MUST support VIRTIO_NET_CTRL_MQ_RSS_CONFIG command per
 \ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) / Setting RSS parameters}.
\item Otherwise the device MUST support VIRTIO_NET_CTRL_MQ_HASH_CONFIG command per
 \ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode / Hash calculation}.
\end{itemize}

The per-packet hash calculation can depend on the IP packet type. See
\hyperref[intro:IP]{[IP]}, \hyperref[intro:UDP]{[UDP]} and \hyperref[intro:TCP]{[TCP]}.

\subparagraph{Supported/enabled hash types}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Supported/enabled hash types}
Hash types applicable for IPv4 packets:
\begin{lstlisting}
#define VIRTIO_NET_HASH_TYPE_IPv4              (1 << 0)
#define VIRTIO_NET_HASH_TYPE_TCPv4             (1 << 1)
#define VIRTIO_NET_HASH_TYPE_UDPv4             (1 << 2)
\end{lstlisting}
Hash types applicable for IPv6 packets without extension headers
\begin{lstlisting}
#define VIRTIO_NET_HASH_TYPE_IPv6              (1 << 3)
#define VIRTIO_NET_HASH_TYPE_TCPv6             (1 << 4)
#define VIRTIO_NET_HASH_TYPE_UDPv6             (1 << 5)
\end{lstlisting}
Hash types applicable for IPv6 packets with extension headers
\begin{lstlisting}
#define VIRTIO_NET_HASH_TYPE_IP_EX             (1 << 6)
#define VIRTIO_NET_HASH_TYPE_TCP_EX            (1 << 7)
#define VIRTIO_NET_HASH_TYPE_UDP_EX            (1 << 8)
\end{lstlisting}

\subparagraph{IPv4 packets}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / IPv4 packets}
The device calculates the hash on IPv4 packets according to 'Enabled hash types' bitmask as follows:
\begin{itemize}
\item If VIRTIO_NET_HASH_TYPE_TCPv4 is set and the packet has
a TCP header, the hash is calculated over the following fields:
\begin{itemize}
\item Source IP address
\item Destination IP address
\item Source TCP port
\item Destination TCP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_UDPv4 is set and the
packet has a UDP header, the hash is calculated over the following fields:
\begin{itemize}
\item Source IP address
\item Destination IP address
\item Source UDP port
\item Destination UDP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_IPv4 is set, the hash is
calculated over the following fields:
\begin{itemize}
\item Source IP address
\item Destination IP address
\end{itemize}
\item Else the device does not calculate the hash
\end{itemize}

\subparagraph{IPv6 packets without extension header}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / IPv6 packets without extension header}
The device calculates the hash on IPv6 packets without extension
headers according to 'Enabled hash types' bitmask as follows:
\begin{itemize}
\item If VIRTIO_NET_HASH_TYPE_TCPv6 is set and the packet has
a TCPv6 header, the hash is calculated over the following fields:
\begin{itemize}
\item Source IPv6 address
\item Destination IPv6 address
\item Source TCP port
\item Destination TCP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_UDPv6 is set and the
packet has a UDPv6 header, the hash is calculated over the following fields:
\begin{itemize}
\item Source IPv6 address
\item Destination IPv6 address
\item Source UDP port
\item Destination UDP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_IPv6 is set, the hash is
calculated over the following fields:
\begin{itemize}
\item Source IPv6 address
\item Destination IPv6 address
\end{itemize}
\item Else the device does not calculate the hash
\end{itemize}

\subparagraph{IPv6 packets with extension header}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / IPv6 packets with extension header}
The device calculates the hash on IPv6 packets with extension
headers according to 'Enabled hash types' bitmask as follows:
\begin{itemize}
\item If VIRTIO_NET_HASH_TYPE_TCP_EX is set and the packet
has a TCPv6 header, the hash is calculated over the following fields:
\begin{itemize}
\item Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
\item IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
\item Source TCP port
\item Destination TCP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_UDP_EX is set and the
packet has a UDPv6 header, the hash is calculated over the following fields:
\begin{itemize}
\item Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
\item IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
\item Source UDP port
\item Destination UDP port
\end{itemize}
\item Else if VIRTIO_NET_HASH_TYPE_IP_EX is set, the hash is
calculated over the following fields:
\begin{itemize}
\item Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
\item IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
\end{itemize}
\item Else skip IPv6 extension headers and calculate the hash as
defined for an IPv6 packet without extension headers
(see \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / IPv6 packets without extension header}).
\end{itemize}

\paragraph{Inner Header Hash}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Inner Header Hash}

If VIRTIO_NET_F_HASH_TUNNEL has been negotiated, the driver can send the command
VIRTIO_NET_CTRL_HASH_TUNNEL_SET to configure the calculation of the inner header hash.

\begin{lstlisting}
struct virtnet_hash_tunnel {
    le32 enabled_tunnel_types;
};

#define VIRTIO_NET_CTRL_HASH_TUNNEL 7
 #define VIRTIO_NET_CTRL_HASH_TUNNEL_SET 0
\end{lstlisting}

Field \field{enabled_tunnel_types} contains the bitmask of encapsulation types enabled for inner header hash.
See \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets /
Hash calculation for incoming packets / Encapsulation types supported/enabled for inner header hash}.

The class VIRTIO_NET_CTRL_HASH_TUNNEL has one command:
VIRTIO_NET_CTRL_HASH_TUNNEL_SET sets \field{enabled_tunnel_types} for the device using the
virtnet_hash_tunnel structure, which is read-only for the device.

Inner header hash is disabled by VIRTIO_NET_CTRL_HASH_TUNNEL_SET with \field{enabled_tunnel_types} set to 0.

Initially (before the driver sends any VIRTIO_NET_CTRL_HASH_TUNNEL_SET command) all
encapsulation types are disabled for inner header hash.

\subparagraph{Encapsulated packet}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Encapsulated packet}

Multiple tunneling protocols allow encapsulating an inner, payload packet in an outer, encapsulated packet.
The encapsulated packet thus contains an outer header and an inner header, and the device calculates the
hash over either the inner header or the outer header.

If VIRTIO_NET_F_HASH_TUNNEL is negotiated and a received encapsulated packet's outer header matches one of the
encapsulation types enabled in \field{enabled_tunnel_types}, then the device uses the inner header for hash
calculations (only a single level of encapsulation is currently supported).

If VIRTIO_NET_F_HASH_TUNNEL is negotiated and a received packet's (outer) header does not match any encapsulation
types enabled in \field{enabled_tunnel_types}, then the device uses the outer header for hash calculations.

\subparagraph{Encapsulation types supported/enabled for inner header hash}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets /
Hash calculation for incoming packets / Encapsulation types supported/enabled for inner header hash}

Encapsulation types applicable for inner header hash:
\begin{lstlisting}[escapechar=|]
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_2784    (1 << 0) /* |\hyperref[intro:rfc2784]{[RFC2784]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_2890    (1 << 1) /* |\hyperref[intro:rfc2890]{[RFC2890]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_7676    (1 << 2) /* |\hyperref[intro:rfc7676]{[RFC7676]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_UDP     (1 << 3) /* |\hyperref[intro:rfc8086]{[GRE-in-UDP]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_VXLAN       (1 << 4) /* |\hyperref[intro:vxlan]{[VXLAN]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_VXLAN_GPE   (1 << 5) /* |\hyperref[intro:vxlan-gpe]{[VXLAN-GPE]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GENEVE      (1 << 6) /* |\hyperref[intro:geneve]{[GENEVE]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_IPIP        (1 << 7) /* |\hyperref[intro:ipip]{[IPIP]}| */
#define VIRTIO_NET_HASH_TUNNEL_TYPE_NVGRE       (1 << 8) /* |\hyperref[intro:nvgre]{[NVGRE]}| */
\end{lstlisting}

\subparagraph{Advice}
Example uses of the inner header hash:
\begin{itemize}
\item Legacy tunneling protocols, lacking the outer header entropy, can use RSS with the inner header hash to
      distribute flows with identical outer but different inner headers across various queues, improving performance.
\item Identify an inner flow distributed across multiple outer tunnels.
\end{itemize}

As using the inner header hash completely discards the outer header entropy, care must be taken
if the inner header is controlled by an adversary, as the adversary can then intentionally create
configurations with insufficient entropy.

Besides disabling the inner header hash, mitigations would depend on how the hash is used. When the hash
use is limited to the RSS queue selection, the inner header hash may have quality of service (QoS) limitations.

\devicenormative{\subparagraph}{Inner Header Hash}{Device Types / Network Device / Device Operation / Control Virtqueue / Inner Header Hash}

If the (outer) header of the received packet does not match any encapsulation types enabled
in \field{enabled_tunnel_types}, the device MUST calculate the hash on the outer header.

If the device receives any bits in \field{enabled_tunnel_types} which are not set in \field{supported_tunnel_types},
it SHOULD respond to the VIRTIO_NET_CTRL_HASH_TUNNEL_SET command with VIRTIO_NET_ERR.

If the driver sets \field{enabled_tunnel_types} to 0 through VIRTIO_NET_CTRL_HASH_TUNNEL_SET or upon the device reset,
the device MUST disable the inner header hash for all encapsulation types.

\drivernormative{\subparagraph}{Inner Header Hash}{Device Types / Network Device / Device Operation / Control Virtqueue / Inner Header Hash}

The driver MUST have negotiated the VIRTIO_NET_F_HASH_TUNNEL feature when issuing the VIRTIO_NET_CTRL_HASH_TUNNEL_SET command.

The driver MUST NOT set any bits in \field{enabled_tunnel_types} which are not set in \field{supported_tunnel_types}.

The driver MUST ignore bits in \field{supported_tunnel_types} which are not documented in this specification.

\paragraph{Hash reporting for incoming packets}
\label{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash reporting for incoming packets}

If VIRTIO_NET_F_HASH_REPORT was negotiated and
 the device has calculated the hash for the packet, the device fills \field{hash_report} with the report type of calculated hash
and \field{hash_value} with the value of calculated hash.

If VIRTIO_NET_F_HASH_REPORT was negotiated but due to any reason the
hash was not calculated, the device sets \field{hash_report} to VIRTIO_NET_HASH_REPORT_NONE.

Possible values that the device can report in \field{hash_report} are defined below.
They correspond to supported hash types defined in
\ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Supported/enabled hash types}
as follows:

VIRTIO_NET_HASH_TYPE_XXX = 1 << (VIRTIO_NET_HASH_REPORT_XXX - 1)

\begin{lstlisting}
#define VIRTIO_NET_HASH_REPORT_NONE            0
#define VIRTIO_NET_HASH_REPORT_IPv4            1
#define VIRTIO_NET_HASH_REPORT_TCPv4           2
#define VIRTIO_NET_HASH_REPORT_UDPv4           3
#define VIRTIO_NET_HASH_REPORT_IPv6            4
#define VIRTIO_NET_HASH_REPORT_TCPv6           5
#define VIRTIO_NET_HASH_REPORT_UDPv6           6
#define VIRTIO_NET_HASH_REPORT_IPv6_EX         7
#define VIRTIO_NET_HASH_REPORT_TCPv6_EX        8
#define VIRTIO_NET_HASH_REPORT_UDPv6_EX        9
\end{lstlisting}

\subsubsection{Control Virtqueue}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue}

The driver uses the control virtqueue (if VIRTIO_NET_F_CTRL_VQ is
negotiated) to send commands to manipulate various features of
the device which would not easily map into the configuration
space.

All commands are of the following form:

\begin{lstlisting}
struct virtio_net_ctrl {
        u8 class;
        u8 command;
        u8 command-specific-data[];
        u8 ack;
        u8 command-specific-result[];
};

/* ack values */
#define VIRTIO_NET_OK     0
#define VIRTIO_NET_ERR    1
\end{lstlisting}

The \field{class}, \field{command} and command-specific-data are set by the
driver, and the device sets the \field{ack} byte and optionally
\field{command-specific-result}. There is little the driver can
do except issue a diagnostic if \field{ack} is not VIRTIO_NET_OK.

The command VIRTIO_NET_CTRL_STATS_QUERY and VIRTIO_NET_CTRL_STATS_GET contain
\field{command-specific-result}.

\paragraph{Packet Receive Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Packet Receive Filtering}
\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Setting Promiscuous Mode}%old label for latexdiff

If the VIRTIO_NET_F_CTRL_RX and VIRTIO_NET_F_CTRL_RX_EXTRA
features are negotiated, the driver can send control commands for
promiscuous mode, multicast, unicast and broadcast receiving.

\begin{note}
In general, these commands are best-effort: unwanted
packets could still arrive.
\end{note}

\begin{lstlisting}
#define VIRTIO_NET_CTRL_RX    0
 #define VIRTIO_NET_CTRL_RX_PROMISC      0
 #define VIRTIO_NET_CTRL_RX_ALLMULTI     1
 #define VIRTIO_NET_CTRL_RX_ALLUNI       2
 #define VIRTIO_NET_CTRL_RX_NOMULTI      3
 #define VIRTIO_NET_CTRL_RX_NOUNI        4
 #define VIRTIO_NET_CTRL_RX_NOBCAST      5
\end{lstlisting}


\devicenormative{\subparagraph}{Packet Receive Filtering}{Device Types / Network Device / Device Operation / Control Virtqueue / Packet Receive Filtering}

If the VIRTIO_NET_F_CTRL_RX feature has been negotiated,
the device MUST support the following VIRTIO_NET_CTRL_RX class
commands:
\begin{itemize}
\item VIRTIO_NET_CTRL_RX_PROMISC turns promiscuous mode on and
off. The command-specific-data is one byte containing 0 (off) or
1 (on). If promiscuous mode is on, the device SHOULD receive all
incoming packets.
This SHOULD take effect even if one of the other modes set by
a VIRTIO_NET_CTRL_RX class command is on.
\item VIRTIO_NET_CTRL_RX_ALLMULTI turns all-multicast receive on and
off. The command-specific-data is one byte containing 0 (off) or
1 (on). When all-multicast receive is on the device SHOULD allow
all incoming multicast packets.
\end{itemize}

If the VIRTIO_NET_F_CTRL_RX_EXTRA feature has been negotiated,
the device MUST support the following VIRTIO_NET_CTRL_RX class
commands:
\begin{itemize}
\item VIRTIO_NET_CTRL_RX_ALLUNI turns all-unicast receive on and
off. The command-specific-data is one byte containing 0 (off) or
1 (on). When all-unicast receive is on the device SHOULD allow
all incoming unicast packets.
\item VIRTIO_NET_CTRL_RX_NOMULTI suppresses multicast receive.
The command-specific-data is one byte containing 0 (multicast
receive allowed) or 1 (multicast receive suppressed).
When multicast receive is suppressed, the device SHOULD NOT
send multicast packets to the driver.
This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLMULTI is on.
This filter SHOULD NOT apply to broadcast packets.
\item VIRTIO_NET_CTRL_RX_NOUNI suppresses unicast receive.
The command-specific-data is one byte containing 0 (unicast
receive allowed) or 1 (unicast receive suppressed).
When unicast receive is suppressed, the device SHOULD NOT
send unicast packets to the driver.
This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLUNI is on.
\item VIRTIO_NET_CTRL_RX_NOBCAST suppresses broadcast receive.
The command-specific-data is one byte containing 0 (broadcast
receive allowed) or 1 (broadcast receive suppressed).
When broadcast receive is suppressed, the device SHOULD NOT
send broadcast packets to the driver.
This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLMULTI is on.
\end{itemize}

\drivernormative{\subparagraph}{Packet Receive Filtering}{Device Types / Network Device / Device Operation / Control Virtqueue / Packet Receive Filtering}

If the VIRTIO_NET_F_CTRL_RX feature has not been negotiated,
the driver MUST NOT issue commands VIRTIO_NET_CTRL_RX_PROMISC or
VIRTIO_NET_CTRL_RX_ALLMULTI.

If the VIRTIO_NET_F_CTRL_RX_EXTRA feature has not been negotiated,
the driver MUST NOT issue commands
 VIRTIO_NET_CTRL_RX_ALLUNI,
 VIRTIO_NET_CTRL_RX_NOMULTI,
 VIRTIO_NET_CTRL_RX_NOUNI or
 VIRTIO_NET_CTRL_RX_NOBCAST.

\paragraph{Setting MAC Address Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Setting MAC Address Filtering}

If the VIRTIO_NET_F_CTRL_RX feature is negotiated, the driver can
send control commands for MAC address filtering.

\begin{lstlisting}
struct virtio_net_ctrl_mac {
        le32 entries;
        u8 macs[entries][6];
};

#define VIRTIO_NET_CTRL_MAC    1
 #define VIRTIO_NET_CTRL_MAC_TABLE_SET        0
 #define VIRTIO_NET_CTRL_MAC_ADDR_SET         1
\end{lstlisting}

The device can filter incoming packets by any number of destination
MAC addresses\footnote{Since there are no guarantees, it can use a hash filter or
silently switch to allmulti or promiscuous mode if it is given too
many addresses.
}. This table is set using the class
VIRTIO_NET_CTRL_MAC and the command VIRTIO_NET_CTRL_MAC_TABLE_SET. The
command-specific-data is two variable length tables of 6-byte MAC
addresses (as described in struct virtio_net_ctrl_mac). The first table contains unicast addresses, and the second
contains multicast addresses.

The VIRTIO_NET_CTRL_MAC_ADDR_SET command is used to set the
default MAC address which rx filtering
accepts (and if VIRTIO_NET_F_MAC has been negotiated,
this will be reflected in \field{mac} in config space).

The command-specific-data for VIRTIO_NET_CTRL_MAC_ADDR_SET is
the 6-byte MAC address.

\devicenormative{\subparagraph}{Setting MAC Address Filtering}{Device Types / Network Device / Device Operation / Control Virtqueue / Setting MAC Address Filtering}

The device MUST have an empty MAC filtering table on reset.

The device MUST update the MAC filtering table before it consumes
the VIRTIO_NET_CTRL_MAC_TABLE_SET command.

The device MUST update \field{mac} in config space before it consumes
the VIRTIO_NET_CTRL_MAC_ADDR_SET command, if VIRTIO_NET_F_MAC has
been negotiated.

The device SHOULD drop incoming packets which have a destination MAC which
matches neither the \field{mac} (or that set with VIRTIO_NET_CTRL_MAC_ADDR_SET)
nor the MAC filtering table.

\drivernormative{\subparagraph}{Setting MAC Address Filtering}{Device Types / Network Device / Device Operation / Control Virtqueue / Setting MAC Address Filtering}

If VIRTIO_NET_F_CTRL_RX has not been negotiated,
the driver MUST NOT issue VIRTIO_NET_CTRL_MAC class commands.

If VIRTIO_NET_F_CTRL_RX has been negotiated,
the driver SHOULD issue VIRTIO_NET_CTRL_MAC_ADDR_SET
to set the default mac if it is different from \field{mac}.

The driver MUST follow the VIRTIO_NET_CTRL_MAC_TABLE_SET command
by a le32 number, followed by that number of non-multicast
MAC addresses, followed by another le32 number, followed by
that number of multicast addresses.  Either number MAY be 0.

\subparagraph{Legacy Interface: Setting MAC Address Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Setting MAC Address Filtering / Legacy Interface: Setting MAC Address Filtering}
When using the legacy interface, transitional devices and drivers
MUST format \field{entries} in struct virtio_net_ctrl_mac
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.

Legacy drivers that didn't negotiate VIRTIO_NET_F_CTRL_MAC_ADDR
changed \field{mac} in config space when NIC is accepting
incoming packets. These drivers always wrote the mac value from
first to last byte, therefore after detecting such drivers,
a transitional device MAY defer MAC update, or MAY defer
processing incoming packets until driver writes the last byte
of \field{mac} in the config space.

\paragraph{VLAN Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / VLAN Filtering}

If the driver negotiates the VIRTIO_NET_F_CTRL_VLAN feature, it
can control a VLAN filter table in the device. The VLAN filter
table applies only to VLAN tagged packets.

When VIRTIO_NET_F_CTRL_VLAN is negotiated, the device starts with
an empty VLAN filter table.

\begin{note}
Similar to the MAC address based filtering, the VLAN filtering
is also best-effort: unwanted packets could still arrive.
\end{note}

\begin{lstlisting}
#define VIRTIO_NET_CTRL_VLAN       2
 #define VIRTIO_NET_CTRL_VLAN_ADD             0
 #define VIRTIO_NET_CTRL_VLAN_DEL             1
\end{lstlisting}

Both the VIRTIO_NET_CTRL_VLAN_ADD and VIRTIO_NET_CTRL_VLAN_DEL
command take a little-endian 16-bit VLAN id as the command-specific-data.

VIRTIO_NET_CTRL_VLAN_ADD command adds the specified VLAN to the
VLAN filter table.

VIRTIO_NET_CTRL_VLAN_DEL command removes the specified VLAN from
the VLAN filter table.

\devicenormative{\subparagraph}{VLAN Filtering}{Device Types / Network Device / Device Operation / Control Virtqueue / VLAN Filtering}

When VIRTIO_NET_F_CTRL_VLAN is not negotiated, the device MUST
accept all VLAN tagged packets.

When VIRTIO_NET_F_CTRL_VLAN is negotiated, the device MUST
accept all VLAN tagged packets whose VLAN tag is present in
the VLAN filter table and SHOULD drop all VLAN tagged packets
whose VLAN tag is absent in the VLAN filter table.

\subparagraph{Legacy Interface: VLAN Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / VLAN Filtering / Legacy Interface: VLAN Filtering}
When using the legacy interface, transitional devices and drivers
MUST format the VLAN id
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.

\paragraph{Gratuitous Packet Sending}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Gratuitous Packet Sending}

If the driver negotiates the VIRTIO_NET_F_GUEST_ANNOUNCE (depends
on VIRTIO_NET_F_CTRL_VQ), the device can ask the driver to send gratuitous
packets; this is usually done after the guest has been physically
migrated, and needs to announce its presence on the new network
links. (As hypervisor does not have the knowledge of guest
network configuration (eg. tagged vlan) it is simplest to prod
the guest in this way).

\begin{lstlisting}
#define VIRTIO_NET_CTRL_ANNOUNCE       3
 #define VIRTIO_NET_CTRL_ANNOUNCE_ACK             0
\end{lstlisting}

The driver checks VIRTIO_NET_S_ANNOUNCE bit in the device configuration \field{status} field
when it notices the changes of device configuration. The
command VIRTIO_NET_CTRL_ANNOUNCE_ACK is used to indicate that
driver has received the notification and device clears the
VIRTIO_NET_S_ANNOUNCE bit in \field{status}.

Processing this notification involves:

\begin{enumerate}
\item Sending the gratuitous packets (eg. ARP) or marking there are pending
  gratuitous packets to be sent and letting deferred routine to
  send them.

\item Sending VIRTIO_NET_CTRL_ANNOUNCE_ACK command through control
  vq.
\end{enumerate}

\drivernormative{\subparagraph}{Gratuitous Packet Sending}{Device Types / Network Device / Device Operation / Control Virtqueue / Gratuitous Packet Sending}

If the driver negotiates VIRTIO_NET_F_GUEST_ANNOUNCE, it SHOULD notify
network peers of its new location after it sees the VIRTIO_NET_S_ANNOUNCE bit
in \field{status}.  The driver MUST send a command on the command queue
with class VIRTIO_NET_CTRL_ANNOUNCE and command VIRTIO_NET_CTRL_ANNOUNCE_ACK.

\devicenormative{\subparagraph}{Gratuitous Packet Sending}{Device Types / Network Device / Device Operation / Control Virtqueue / Gratuitous Packet Sending}

If VIRTIO_NET_F_GUEST_ANNOUNCE is negotiated, the device MUST clear the
VIRTIO_NET_S_ANNOUNCE bit in \field{status} upon receipt of a command buffer
with class VIRTIO_NET_CTRL_ANNOUNCE and command VIRTIO_NET_CTRL_ANNOUNCE_ACK
before marking the buffer as used.

\paragraph{Device operation in multiqueue mode}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device operation in multiqueue mode}

This specification defines the following modes that a device MAY implement for operation with multiple transmit/receive virtqueues:
\begin{itemize}
\item Automatic receive steering as defined in \ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode}.
 If a device supports this mode, it offers the VIRTIO_NET_F_MQ feature bit.
\item Receive-side scaling as defined in \ref{devicenormative:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) / RSS processing}.
 If a device supports this mode, it offers the VIRTIO_NET_F_RSS feature bit.
\end{itemize}

A device MAY support one of these features or both. The driver MAY negotiate any set of these features that the device supports.

Multiqueue is disabled by default.

The driver enables multiqueue by sending a command using \field{class} VIRTIO_NET_CTRL_MQ. The \field{command} selects the mode of multiqueue operation, as follows:
\begin{lstlisting}
#define VIRTIO_NET_CTRL_MQ    4
 #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET        0 (for automatic receive steering)
 #define VIRTIO_NET_CTRL_MQ_RSS_CONFIG          1 (for configurable receive steering)
 #define VIRTIO_NET_CTRL_MQ_HASH_CONFIG         2 (for configurable hash calculation)
\end{lstlisting}

If more than one multiqueue mode is negotiated, the resulting device configuration is defined by the last command sent by the driver.

\paragraph{Automatic receive steering in multiqueue mode}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode}

If the driver negotiates the VIRTIO_NET_F_MQ feature bit (depends on VIRTIO_NET_F_CTRL_VQ), it MAY transmit outgoing packets on one
of the multiple transmitq1\ldots transmitqN and ask the device to
queue incoming packets into one of the multiple receiveq1\ldots receiveqN
depending on the packet flow.

The driver enables multiqueue by
sending the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command, specifying
the number of the transmit and receive queues to be used up to
\field{max_virtqueue_pairs}; subsequently,
transmitq1\ldots transmitqn and receiveq1\ldots receiveqn where
n=\field{virtqueue_pairs} MAY be used.
\begin{lstlisting}
struct virtio_net_ctrl_mq_pairs_set {
       le16 virtqueue_pairs;
};
#define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN        1
#define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX        0x8000

\end{lstlisting}

When multiqueue is enabled by VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command, the device MUST use automatic receive steering
based on packet flow. Programming of the receive steering
classificator is implicit. After the driver transmitted a packet of a
flow on transmitqX, the device SHOULD cause incoming packets for that flow to
be steered to receiveqX. For uni-directional protocols, or where
no packets have been transmitted yet, the device MAY steer a packet
to a random queue out of the specified receiveq1\ldots receiveqn.

Multiqueue is disabled by VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET with \field{virtqueue_pairs} to 1 (this is
the default) and waiting for the device to use the command buffer.

\drivernormative{\subparagraph}{Automatic receive steering in multiqueue mode}{Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode}

The driver MUST configure the virtqueues before enabling them with the
VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command.

The driver MUST NOT request a \field{virtqueue_pairs} of 0 or
greater than \field{max_virtqueue_pairs} in the device configuration space.

The driver MUST queue packets only on any transmitq1 before the
VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command.

The driver MUST NOT queue packets on transmit queues greater than
\field{virtqueue_pairs} once it has placed the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command in the available ring.

\devicenormative{\subparagraph}{Automatic receive steering in multiqueue mode}{Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode}

After initialization of reset, the device MUST queue packets only on receiveq1.

The device MUST NOT queue packets on receive queues greater than
\field{virtqueue_pairs} once it has placed the
VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command in a used buffer.

If the destination receive queue is being reset (See \ref{sec:Basic Facilities of a Virtio Device / Virtqueues / Virtqueue Reset}),
the device SHOULD re-select another random queue. If all receive queues are
being reset, the device MUST drop the packet.

\subparagraph{Legacy Interface: Automatic receive steering in multiqueue mode}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode / Legacy Interface: Automatic receive steering in multiqueue mode}
When using the legacy interface, transitional devices and drivers
MUST format \field{virtqueue_pairs}
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.

\subparagraph{Hash calculation}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode / Hash calculation}
If VIRTIO_NET_F_HASH_REPORT was negotiated and the device uses automatic receive steering,
the device MUST support a command to configure hash calculation parameters.

The driver provides parameters for hash calculation as follows:

\field{class} VIRTIO_NET_CTRL_MQ, \field{command} VIRTIO_NET_CTRL_MQ_HASH_CONFIG.

The \field{command-specific-data} has following format:
\begin{lstlisting}
struct virtio_net_hash_config {
    le32 hash_types;
    le16 reserved[4];
    u8 hash_key_length;
    u8 hash_key_data[hash_key_length];
};
\end{lstlisting}
Field \field{hash_types} contains a bitmask of allowed hash types as
defined in
\ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Supported/enabled hash types}.
Initially the device has all hash types disabled and reports only VIRTIO_NET_HASH_REPORT_NONE.

Field \field{reserved} MUST contain zeroes. It is defined to make the structure to match the layout of virtio_net_rss_config structure,
defined in \ref{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS)}.

Fields \field{hash_key_length} and \field{hash_key_data} define the key to be used in hash calculation.

\paragraph{Receive-side scaling (RSS)}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS)}
A device offers the feature VIRTIO_NET_F_RSS if it supports RSS receive steering with Toeplitz hash calculation and configurable parameters.

A driver queries RSS capabilities of the device by reading device configuration as defined in \ref{sec:Device Types / Network Device / Device configuration layout}

\subparagraph{Setting RSS parameters}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) / Setting RSS parameters}

Driver sends a VIRTIO_NET_CTRL_MQ_RSS_CONFIG command using the following format for \field{command-specific-data}:
\begin{lstlisting}
struct rss_rq_id {
   le16 vq_index_1_16: 15; /* Bits 1 to 16 of the virtqueue index */
   le16 reserved: 1; /* Set to zero */
};

struct virtio_net_rss_config {
    le32 hash_types;
    le16 indirection_table_mask;
    struct rss_rq_id unclassified_queue;
    struct rss_rq_id indirection_table[indirection_table_length];
    le16 max_tx_vq;
    u8 hash_key_length;
    u8 hash_key_data[hash_key_length];
};
\end{lstlisting}
Field \field{hash_types} contains a bitmask of allowed hash types as
defined in
\ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets / Supported/enabled hash types}.

Field \field{indirection_table_mask} is a mask to be applied to
the calculated hash to produce an index in the
\field{indirection_table} array.
Number of entries in \field{indirection_table} is (\field{indirection_table_mask} + 1).

\field{rss_rq_id} is a receive virtqueue id. \field{vq_index_1_16}
consists of bits 1 to 16 of a virtqueue index. For example, a
\field{vq_index_1_16} value of 3 corresponds to virtqueue index 6,
which maps to receiveq4.

Field \field{unclassified_queue} specifies the receive virtqueue id in which to
place unclassified packets.

Field \field{indirection_table} is an array of receive virtqueues ids.

A driver sets \field{max_tx_vq} to inform a device how many transmit virtqueues it may use (transmitq1\ldots transmitq \field{max_tx_vq}).

Fields \field{hash_key_length} and \field{hash_key_data} define the key to be used in hash calculation.

\drivernormative{\subparagraph}{Setting RSS parameters}{Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) }

A driver MUST NOT send the VIRTIO_NET_CTRL_MQ_RSS_CONFIG command if the feature VIRTIO_NET_F_RSS has not been negotiated.

A driver MUST fill the \field{indirection_table} array only with
enabled receive virtqueues ids.

The number of entries in \field{indirection_table} (\field{indirection_table_mask} + 1) MUST be a power of two.

A driver MUST use \field{indirection_table_mask} values that are less than \field{rss_max_indirection_table_length} reported by a device.

A driver MUST NOT set any VIRTIO_NET_HASH_TYPE_ flags that are not supported by a device.

\devicenormative{\subparagraph}{RSS processing}{Device Types / Network Device / Device Operation / Control Virtqueue / Receive-side scaling (RSS) / RSS processing}
The device MUST determine the destination queue for a network packet as follows:
\begin{itemize}
\item Calculate the hash of the packet as defined in \ref{sec:Device Types / Network Device / Device Operation / Processing of Incoming Packets / Hash calculation for incoming packets}.
\item If the device did not calculate the hash for the specific packet, the device directs the packet to the receiveq specified by \field{unclassified_queue} of virtio_net_rss_config structure.
\item Apply \field{indirection_table_mask} to the calculated hash
and use the result as the index in the indirection table to get
the destination receive virtqueue id.
\item If the destination receive queue is being reset (See \ref{sec:Basic Facilities of a Virtio Device / Virtqueues / Virtqueue Reset}), the device MUST drop the packet.
\end{itemize}

\paragraph{RSS Context}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / RSS Context}

An RSS context consists of configurable parameters specified by \ref{sec:Device Types / Network Device
/ Device Operation / Control Virtqueue / Receive-side scaling (RSS)}.

The RSS configuration supported by VIRTIO_NET_F_RSS is considered the default RSS configuration.

The device offers the feature VIRTIO_NET_F_RSS_CONTEXT if it supports one or multiple RSS contexts
(excluding the default RSS configuration) and configurable parameters.

\subparagraph{Querying RSS Context Capability}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / RSS Context / Querying RSS Context Capability}

\begin{lstlisting}
#define VIRTNET_RSS_CTX_CTRL 9
 #define VIRTNET_RSS_CTX_CTRL_CAP_GET  0
 #define VIRTNET_RSS_CTX_CTRL_ADD      1
 #define VIRTNET_RSS_CTX_CTRL_MOD      2
 #define VIRTNET_RSS_CTX_CTRL_DEL      3

struct virtnet_rss_ctx_cap {
    le16 max_rss_contexts;
}
\end{lstlisting}

Field \field{max_rss_contexts} specifies the maximum number of RSS contexts \ref{sec:Device Types / Network Device /
Device Operation / Control Virtqueue / RSS Context} supported by the device.

The driver queries the RSS context capability of the device by sending the command VIRTNET_RSS_CTX_CTRL_CAP_GET
with the structure virtnet_rss_ctx_cap.

For the command VIRTNET_RSS_CTX_CTRL_CAP_GET, the structure virtnet_rss_ctx_cap is write-only for the device.

\subparagraph{Setting RSS Context Parameters}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / RSS Context / Setting RSS Context Parameters}

\begin{lstlisting}
struct virtnet_rss_ctx_add_modify {
    le16 rss_ctx_id;
    u8 reserved[6];
    struct virtio_net_rss_config rss;
};

struct virtnet_rss_ctx_del {
    le16 rss_ctx_id;
};
\end{lstlisting}

RSS context parameters:
\begin{itemize}
\item  \field{rss_ctx_id}: ID of the specific RSS context.
\item  \field{rss}: RSS context parameters of the specific RSS context whose id is \field{rss_ctx_id}.
\end{itemize}

\field{reserved} is reserved and it is ignored by the device.

If the feature VIRTIO_NET_F_RSS_CONTEXT has been negotiated, the driver can send the following
VIRTNET_RSS_CTX_CTRL class commands:
\begin{enumerate}
\item VIRTNET_RSS_CTX_CTRL_ADD: use the structure virtnet_rss_ctx_add_modify to
       add an RSS context configured as \field{rss} and id as \field{rss_ctx_id} for the device.
\item VIRTNET_RSS_CTX_CTRL_MOD: use the structure virtnet_rss_ctx_add_modify to
       configure parameters of the RSS context whose id is \field{rss_ctx_id} as \field{rss} for the device.
\item VIRTNET_RSS_CTX_CTRL_DEL: use the structure virtnet_rss_ctx_del to delete
       the RSS context whose id is \field{rss_ctx_id} for the device.
\end{enumerate}

For commands VIRTNET_RSS_CTX_CTRL_ADD and VIRTNET_RSS_CTX_CTRL_MOD, the structure virtnet_rss_ctx_add_modify is read-only for the device.
For the command VIRTNET_RSS_CTX_CTRL_DEL, the structure virtnet_rss_ctx_del is read-only for the device.

\devicenormative{\subparagraph}{RSS Context}{Device Types / Network Device / Device Operation / Control Virtqueue / RSS Context}

The device MUST set \field{max_rss_contexts} to at least 1 if it offers VIRTIO_NET_F_RSS_CONTEXT.

Upon reset, the device MUST clear all previously configured RSS contexts.

\drivernormative{\subparagraph}{RSS Context}{Device Types / Network Device / Device Operation / Control Virtqueue / RSS Context}

The driver MUST have negotiated the VIRTIO_NET_F_RSS_CONTEXT feature when issuing the VIRTNET_RSS_CTX_CTRL class commands.

The driver MUST set \field{rss_ctx_id} to between 1 and \field{max_rss_contexts} inclusive.

The driver MUST NOT send the command VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET when the device has successfully configured at least one RSS context.

\paragraph{Offloads State Configuration}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration}

If the VIRTIO_NET_F_CTRL_GUEST_OFFLOADS feature is negotiated, the driver can
send control commands for dynamic offloads state configuration.

\subparagraph{Setting Offloads State}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration / Setting Offloads State}

To configure the offloads, the following layout structure and
definitions are used:

\begin{lstlisting}
le64 offloads;

#define VIRTIO_NET_F_GUEST_CSUM       1
#define VIRTIO_NET_F_GUEST_TSO4       7
#define VIRTIO_NET_F_GUEST_TSO6       8
#define VIRTIO_NET_F_GUEST_ECN        9
#define VIRTIO_NET_F_GUEST_UFO        10
#define VIRTIO_NET_F_GUEST_USO4       54
#define VIRTIO_NET_F_GUEST_USO6       55

#define VIRTIO_NET_CTRL_GUEST_OFFLOADS       5
 #define VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET   0
\end{lstlisting}

The class VIRTIO_NET_CTRL_GUEST_OFFLOADS has one command:
VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET applies the new offloads configuration.

le64 value passed as command data is a bitmask, bits set define
offloads to be enabled, bits cleared - offloads to be disabled.

There is a corresponding device feature for each offload. Upon feature
negotiation corresponding offload gets enabled to preserve backward
compatibility.

\drivernormative{\subparagraph}{Setting Offloads State}{Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration / Setting Offloads State}

A driver MUST NOT enable an offload for which the appropriate feature
has not been negotiated.

\subparagraph{Legacy Interface: Setting Offloads State}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration / Setting Offloads State / Legacy Interface: Setting Offloads State}
When using the legacy interface, transitional devices and drivers
MUST format \field{offloads}
according to the native endian of the guest rather than
(necessarily when not using the legacy interface) little-endian.


\paragraph{Notifications Coalescing}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing}

If the VIRTIO_NET_F_NOTF_COAL feature is negotiated, the driver can
send commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET
for notification coalescing.

If the VIRTIO_NET_F_VQ_NOTF_COAL feature is negotiated, the driver can
send commands VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET
for virtqueue notification coalescing.

\begin{lstlisting}
struct virtio_net_ctrl_coal {
    le32 max_packets;
    le32 max_usecs;
};

struct virtio_net_ctrl_coal_vq {
    le16 vq_index;
    le16 reserved;
    struct virtio_net_ctrl_coal coal;
};

#define VIRTIO_NET_CTRL_NOTF_COAL 6
 #define VIRTIO_NET_CTRL_NOTF_COAL_TX_SET  0
 #define VIRTIO_NET_CTRL_NOTF_COAL_RX_SET 1
 #define VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET 2
 #define VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET 3
\end{lstlisting}

Coalescing parameters:
\begin{itemize}
\item \field{vq_index}: The virtqueue index of an enabled transmit or receive virtqueue.
\item \field{max_usecs} for RX: Maximum number of microseconds to delay a RX notification.
\item \field{max_usecs} for TX: Maximum number of microseconds to delay a TX notification.
\item \field{max_packets} for RX: Maximum number of packets to receive before a RX notification.
\item \field{max_packets} for TX: Maximum number of packets to send before a TX notification.
\end{itemize}

\field{reserved} is reserved and it is ignored by the device.

Read/Write attributes for coalescing parameters:
\begin{itemize}
\item For commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET, the structure virtio_net_ctrl_coal is write-only for the driver.
\item For the command VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET, the structure virtio_net_ctrl_coal_vq is write-only for the driver.
\item For the command VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET, \field{vq_index} and \field{reserved} are write-only
      for the driver, and the structure virtio_net_ctrl_coal is read-only for the driver.
\end{itemize}

The class VIRTIO_NET_CTRL_NOTF_COAL has the following commands:
\begin{enumerate}
\item VIRTIO_NET_CTRL_NOTF_COAL_TX_SET: use the structure virtio_net_ctrl_coal to set the \field{max_usecs} and \field{max_packets} parameters for all transmit virtqueues.
\item VIRTIO_NET_CTRL_NOTF_COAL_RX_SET: use the structure virtio_net_ctrl_coal to set the \field{max_usecs} and \field{max_packets} parameters for all receive virtqueues.
\item VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET: use the structure virtio_net_ctrl_coal_vq to set the \field{max_usecs} and \field{max_packets} parameters
                                        for an enabled transmit/receive virtqueue whose index is \field{vq_index}.
\item VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET: use the structure virtio_net_ctrl_coal_vq to get the \field{max_usecs} and \field{max_packets} parameters
                                        for an enabled transmit/receive virtqueue whose index is \field{vq_index}.
\end{enumerate}

The device may generate notifications more or less frequently than specified by set commands of the VIRTIO_NET_CTRL_NOTF_COAL class.

If coalescing parameters are being set, the device applies the last coalescing parameters set for a
virtqueue, regardless of the command used to set the parameters. Use the following command sequence
with two pairs of virtqueues as an example:
Each of the following commands sets \field{max_usecs} and \field{max_packets} parameters for virtqueues.
\begin{itemize}
\item Command1: VIRTIO_NET_CTRL_NOTF_COAL_RX_SET sets coalescing parameters for virtqueues having index 0 and index 2. Virtqueues having index 1 and index 3 retain their previous parameters.
\item Command2: VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET with \field{vq_index} = 0 sets coalescing parameters for virtqueue having index 0. Virtqueue having index 2 retains the parameters from command1.
\item Command3: VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET with \field{vq_index} = 0, the device responds with coalescing parameters of vq_index 0 set by command2.
\item Command4: VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET with \field{vq_index} = 1 sets coalescing parameters for virtqueue having index 1. Virtqueue having index 3 retains its previous parameters.
\item Command5: VIRTIO_NET_CTRL_NOTF_COAL_TX_SET sets coalescing parameters for virtqueues having index 1 and index 3, and overrides the parameters set by command4.
\item Command6: VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET with \field{vq_index} = 1, the device responds with coalescing parameters of index 1 set by command5.
\end{itemize}

\subparagraph{Operation}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing / Operation}

The device sends a used buffer notification once the notification conditions are met and if the notifications are not suppressed as explained in \ref{sec:Basic Facilities of a Virtio Device / Virtqueues / Used Buffer Notification Suppression}.

When the device has non-zero \field{max_usecs} and non-zero \field{max_packets}, it starts counting microseconds and packets upon receiving/sending a packet.
The device counts packets and microseconds for each receive virtqueue and transmit virtqueue separately.
In this case, the notification conditions are met when \field{max_usecs} microseconds elapse, or upon sending/receiving \field{max_packets} packets, whichever happens first.
Afterwards, the device waits for the next packet and starts counting packets and microseconds again.

When the device has \field{max_usecs} = 0 or \field{max_packets} = 0, the notification conditions are met after every packet received/sent.

\subparagraph{RX Example}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing / RX Example}

If, for example:
\begin{itemize}
\item \field{max_usecs} = 10.
\item \field{max_packets} = 15.
\end{itemize}
then each receive virtqueue of a device will operate as follows:
\begin{itemize}
\item The device will count packets received on each virtqueue until it accumulates 15, or until 10 microseconds elapsed since the first one was received.
\item If the notifications are not suppressed by the driver, the device will send an used buffer notification, otherwise, the device will not send an used buffer notification as long as the notifications are suppressed.
\end{itemize}

\subparagraph{TX Example}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing / TX Example}

If, for example:
\begin{itemize}
\item \field{max_usecs} = 10.
\item \field{max_packets} = 15.
\end{itemize}
then each transmit virtqueue of a device will operate as follows:
\begin{itemize}
\item The device will count packets sent on each virtqueue until it accumulates 15, or until 10 microseconds elapsed since the first one was sent.
\item If the notifications are not suppressed by the driver, the device will send an used buffer notification, otherwise, the device will not send an used buffer notification as long as the notifications are suppressed.
\end{itemize}

\subparagraph{Notifications When Coalescing Parameters Change}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing / Notifications When Coalescing Parameters Change}

When the coalescing parameters of a device change, the device needs to check if the new notification conditions are met and send a used buffer notification if so.

For example, \field{max_packets} = 15 for a device with a single transmit virtqueue: if the device sends 10 packets and afterwards receives a
VIRTIO_NET_CTRL_NOTF_COAL_TX_SET command with \field{max_packets} = 8, then the notification condition is immediately considered to be met;
the device needs to immediately send a used buffer notification, if the notifications are not suppressed by the driver.

\drivernormative{\subparagraph}{Notifications Coalescing}{Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing}

The driver MUST set \field{vq_index} to the virtqueue index of an enabled transmit or receive virtqueue.

The driver MUST have negotiated the VIRTIO_NET_F_NOTF_COAL feature when issuing commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET.

The driver MUST have negotiated the VIRTIO_NET_F_VQ_NOTF_COAL feature when issuing commands VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET.

The driver MUST ignore the values of coalescing parameters received from the VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET command if the device responds with VIRTIO_NET_ERR.

\devicenormative{\subparagraph}{Notifications Coalescing}{Device Types / Network Device / Device Operation / Control Virtqueue / Notifications Coalescing}

The device MUST ignore \field{reserved}.

The device SHOULD respond to VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET commands with VIRTIO_NET_ERR if it was not able to change the parameters.

The device MUST respond to the VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET command with VIRTIO_NET_ERR if it was not able to change the parameters.

The device MUST respond to VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET commands with
VIRTIO_NET_ERR if the designated virtqueue is not an enabled transmit or receive virtqueue.

Upon disabling and re-enabling a transmit virtqueue, the device MUST set the coalescing parameters of the virtqueue
to those configured through the VIRTIO_NET_CTRL_NOTF_COAL_TX_SET command, or, if the driver did not set any TX coalescing parameters, to 0.

Upon disabling and re-enabling a receive virtqueue, the device MUST set the coalescing parameters of the virtqueue
to those configured through the VIRTIO_NET_CTRL_NOTF_COAL_RX_SET command, or, if the driver did not set any RX coalescing parameters, to 0.

The behavior of the device in response to set commands of the VIRTIO_NET_CTRL_NOTF_COAL class is best-effort:
the device MAY generate notifications more or less frequently than specified.

A device SHOULD NOT send used buffer notifications to the driver if the notifications are suppressed, even if the notification conditions are met.

Upon reset, a device MUST initialize all coalescing parameters to 0.

\paragraph{Device Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics}

If the VIRTIO_NET_F_DEVICE_STATS feature is negotiated, the driver can obtain
device statistics from the device by using the following command.

Different types of virtqueues have different statistics. The statistics of the
receiveq are different from those of the transmitq.

The statistics of a certain type of virtqueue are also divided into multiple types
because different types require different features. This enables the expansion
of new statistics.

In one command, the driver can obtain the statistics of one or multiple virtqueues.
Additionally, the driver can obtain multiple type statistics of each virtqueue.

\subparagraph{Query Statistic Capabilities}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Query Statistic Capabilities}

\begin{lstlisting}
#define VIRTIO_NET_CTRL_STATS         8
#define VIRTIO_NET_CTRL_STATS_QUERY   0
#define VIRTIO_NET_CTRL_STATS_GET     1

struct virtio_net_stats_capabilities {

#define VIRTIO_NET_STATS_TYPE_CVQ       (1 << 32)

#define VIRTIO_NET_STATS_TYPE_RX_BASIC  (1 << 0)
#define VIRTIO_NET_STATS_TYPE_RX_CSUM   (1 << 1)
#define VIRTIO_NET_STATS_TYPE_RX_GSO    (1 << 2)
#define VIRTIO_NET_STATS_TYPE_RX_SPEED  (1 << 3)

#define VIRTIO_NET_STATS_TYPE_TX_BASIC  (1 << 16)
#define VIRTIO_NET_STATS_TYPE_TX_CSUM   (1 << 17)
#define VIRTIO_NET_STATS_TYPE_TX_GSO    (1 << 18)
#define VIRTIO_NET_STATS_TYPE_TX_SPEED  (1 << 19)

    le64 supported_stats_types[1];
}
\end{lstlisting}

To obtain device statistic capability, use the VIRTIO_NET_CTRL_STATS_QUERY
command. When the command completes successfully, \field{command-specific-result}
is in the format of \field{struct virtio_net_stats_capabilities}.

\subparagraph{Get Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Get Statistics}

\begin{lstlisting}
struct virtio_net_ctrl_queue_stats {
       struct {
           le16 vq_index;
           le16 reserved[3];
           le64 types_bitmap[1];
       } stats[];
};

struct virtio_net_stats_reply_hdr {
#define VIRTIO_NET_STATS_TYPE_REPLY_CVQ       32

#define VIRTIO_NET_STATS_TYPE_REPLY_RX_BASIC  0
#define VIRTIO_NET_STATS_TYPE_REPLY_RX_CSUM   1
#define VIRTIO_NET_STATS_TYPE_REPLY_RX_GSO    2
#define VIRTIO_NET_STATS_TYPE_REPLY_RX_SPEED  3

#define VIRTIO_NET_STATS_TYPE_REPLY_TX_BASIC  16
#define VIRTIO_NET_STATS_TYPE_REPLY_TX_CSUM   17
#define VIRTIO_NET_STATS_TYPE_REPLY_TX_GSO    18
#define VIRTIO_NET_STATS_TYPE_REPLY_TX_SPEED  19
    u8 type;
    u8 reserved;
    le16 vq_index;
    le16 reserved1;
    le16 size;
}
\end{lstlisting}

To obtain device statistics, use the VIRTIO_NET_CTRL_STATS_GET command with the
\field{command-specific-data} which is in the format of
\field{struct virtio_net_ctrl_queue_stats}. When the command completes
successfully, \field{command-specific-result} contains multiple statistic
results, each statistic result has the \field{struct virtio_net_stats_reply_hdr}
as the header.

The fields of the \field{struct virtio_net_ctrl_queue_stats}:
\begin{description}
    \item [vq_index]
        The index of the virtqueue to obtain the statistics.

    \item [types_bitmap]
        This is a bitmask of the types of statistics to be obtained. Therefore, a
        \field{stats} inside \field{struct virtio_net_ctrl_queue_stats} may
        indicate multiple statistic replies for the virtqueue.
\end{description}

The fields of the \field{struct virtio_net_stats_reply_hdr}:
\begin{description}
    \item [type]
        The type of the reply statistic.

    \item [vq_index]
        The virtqueue index of the reply statistic.

    \item [size]
        The number of bytes for the statistics entry including size of \field{struct virtio_net_stats_reply_hdr}.

\end{description}

\subparagraph{Controlq Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Controlq Statistics}

The structure corresponding to the controlq statistics is
\field{struct virtio_net_stats_cvq}. The corresponding type is
VIRTIO_NET_STATS_TYPE_CVQ. This is for the controlq.

\begin{lstlisting}
struct virtio_net_stats_cvq {
    struct virtio_net_stats_reply_hdr hdr;

    le64 command_num;
    le64 ok_num;
};
\end{lstlisting}

\begin{description}
    \item [command_num]
        The number of commands received by the device including the current command.

    \item [ok_num]
        The number of commands completed successfully by the device including the current command.
\end{description}


\subparagraph{Receiveq Basic Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Receiveq Basic Statistics}

The structure corresponding to the receiveq basic statistics is
\field{struct virtio_net_stats_rx_basic}. The corresponding type is
VIRTIO_NET_STATS_TYPE_RX_BASIC. This is for the receiveq.

Receiveq basic statistics do not require any feature. As long as the device supports
VIRTIO_NET_F_DEVICE_STATS, the following are the receiveq basic statistics.

\begin{lstlisting}
struct virtio_net_stats_rx_basic {
    struct virtio_net_stats_reply_hdr hdr;

    le64 rx_notifications;

    le64 rx_packets;
    le64 rx_bytes;

    le64 rx_interrupts;

    le64 rx_drops;
    le64 rx_drop_overruns;
};
\end{lstlisting}

The packets described below were all presented on the specified virtqueue.
\begin{description}
    \item [rx_notifications]
        The number of driver notifications received by the device for this
        receiveq.

    \item [rx_packets]
        This is the number of packets passed to the driver by the device.

    \item [rx_bytes]
        This is the bytes of packets passed to the driver by the device.

    \item [rx_interrupts]
        The number of interrupts generated by the device for this receiveq.

    \item [rx_drops]
        This is the number of packets dropped by the device. The count includes
        all types of packets dropped by the device.

    \item [rx_drop_overruns]
        This is the number of packets dropped by the device when no more
        descriptors were available.

\end{description}

\subparagraph{Transmitq Basic Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Transmitq Basic Statistics}

The structure corresponding to the transmitq basic statistics is
\field{struct virtio_net_stats_tx_basic}. The corresponding type is
VIRTIO_NET_STATS_TYPE_TX_BASIC. This is for the transmitq.

Transmitq basic statistics do not require any feature. As long as the device supports
VIRTIO_NET_F_DEVICE_STATS, the following are the transmitq basic statistics.

\begin{lstlisting}
struct virtio_net_stats_tx_basic {
    struct virtio_net_stats_reply_hdr hdr;

    le64 tx_notifications;

    le64 tx_packets;
    le64 tx_bytes;

    le64 tx_interrupts;

    le64 tx_drops;
    le64 tx_drop_malformed;
};
\end{lstlisting}

The packets described below are all for a specific virtqueue.
\begin{description}
    \item [tx_notifications]
        The number of driver notifications received by the device for this
        transmitq.

    \item [tx_packets]
        This is the number of packets sent by the device (not the packets
        got from the driver).

    \item [tx_bytes]
        This is the number of bytes sent by the device for all the sent packets
        (not the bytes sent got from the driver).

    \item [tx_interrupts]
        The number of interrupts generated by the device for this transmitq.

    \item [tx_drops]
        The number of packets dropped by the device. The count includes all
        types of packets dropped by the device.

    \item [tx_drop_malformed]
        The number of packets dropped by the device, when the descriptors are
        malformed. For example, the buffer is too short.
\end{description}

\subparagraph{Receiveq CSUM Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Receiveq CSUM Statistics}

The structure corresponding to the receiveq checksum statistics is
\field{struct virtio_net_stats_rx_csum}. The corresponding type is
VIRTIO_NET_STATS_TYPE_RX_CSUM. This is for the receiveq.

Only after the VIRTIO_NET_F_GUEST_CSUM is negotiated, the receiveq checksum
statistics can be obtained.

\begin{lstlisting}
struct virtio_net_stats_rx_csum {
    struct virtio_net_stats_reply_hdr hdr;

    le64 rx_csum_valid;
    le64 rx_needs_csum;
    le64 rx_csum_none;
    le64 rx_csum_bad;
};
\end{lstlisting}

The packets described below were all presented on the specified virtqueue.
\begin{description}
    \item [rx_csum_valid]
        The number of packets with VIRTIO_NET_HDR_F_DATA_VALID.

    \item [rx_needs_csum]
        The number of packets with VIRTIO_NET_HDR_F_NEEDS_CSUM.

    \item [rx_csum_none]
        The number of packets without hardware checksum. The packet here refers
        to the non-TCP/UDP packet that the device cannot recognize.

    \item [rx_csum_bad]
        The number of packets with checksum mismatch.

\end{description}

\subparagraph{Transmitq CSUM Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Transmitq CSUM Statistics}

The structure corresponding to the transmitq checksum statistics is
\field{struct virtio_net_stats_tx_csum}. The corresponding type is
VIRTIO_NET_STATS_TYPE_TX_CSUM. This is for the transmitq.

Only after the VIRTIO_NET_F_CSUM is negotiated, the transmitq checksum
statistics can be obtained.

The following are the transmitq checksum statistics:

\begin{lstlisting}
struct virtio_net_stats_tx_csum {
    struct virtio_net_stats_reply_hdr hdr;

    le64 tx_csum_none;
    le64 tx_needs_csum;
};
\end{lstlisting}

The packets described below are all for a specific virtqueue.
\begin{description}
    \item [tx_csum_none]
        The number of packets which do not require hardware checksum.

    \item [tx_needs_csum]
        The number of packets which require checksum calculation by the device.

\end{description}

\subparagraph{Receiveq GSO Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Receiveq GSO Statistics}

The structure corresponding to the receivq GSO statistics is
\field{struct virtio_net_stats_rx_gso}. The corresponding type is
VIRTIO_NET_STATS_TYPE_RX_GSO. This is for the receiveq.

If one or more of the VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6
have been negotiated, the receiveq GSO statistics can be obtained.

GSO packets refer to packets passed by the device to the driver where
\field{gso_type} is not VIRTIO_NET_HDR_GSO_NONE.

\begin{lstlisting}
struct virtio_net_stats_rx_gso {
    struct virtio_net_stats_reply_hdr hdr;

    le64 rx_gso_packets;
    le64 rx_gso_bytes;
    le64 rx_gso_packets_coalesced;
    le64 rx_gso_bytes_coalesced;
};
\end{lstlisting}

The packets described below were all presented on the specified virtqueue.
\begin{description}
    \item [rx_gso_packets]
        The number of the GSO packets received by the device.

    \item [rx_gso_bytes]
        The bytes of the GSO packets received by the device.
        This includes the header size of the GSO packet.

    \item [rx_gso_packets_coalesced]
        The number of the GSO packets coalesced by the device.

    \item [rx_gso_bytes_coalesced]
        The bytes of the GSO packets coalesced by the device.
        This includes the header size of the GSO packet.
\end{description}

\subparagraph{Transmitq GSO Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Transmitq GSO Statistics}

The structure corresponding to the transmitq GSO statistics is
\field{struct virtio_net_stats_tx_gso}. The corresponding type is
VIRTIO_NET_STATS_TYPE_TX_GSO. This is for the transmitq.

If one or more of the VIRTIO_NET_F_HOST_TSO4, VIRTIO_NET_F_HOST_TSO6,
VIRTIO_NET_F_HOST_USO options have been negotiated, the transmitq GSO statistics
can be obtained.

GSO packets refer to packets passed by the driver to the device where
\field{gso_type} is not VIRTIO_NET_HDR_GSO_NONE.
See more \ref{sec:Device Types / Network Device / Device Operation / Packet
Transmission}.

\begin{lstlisting}
struct virtio_net_stats_tx_gso {
    struct virtio_net_stats_reply_hdr hdr;

    le64 tx_gso_packets;
    le64 tx_gso_bytes;
    le64 tx_gso_segments;
    le64 tx_gso_segments_bytes;
    le64 tx_gso_packets_noseg;
    le64 tx_gso_bytes_noseg;
};
\end{lstlisting}

The packets described below are all for a specific virtqueue.
\begin{description}
    \item [tx_gso_packets]
        The number of the GSO packets sent by the device.

    \item [tx_gso_bytes]
        The bytes of the GSO packets sent by the device.

    \item [tx_gso_segments]
        The number of segments prepared from GSO packets.

    \item [tx_gso_segments_bytes]
        The bytes of segments prepared from GSO packets.

    \item [tx_gso_packets_noseg]
        The number of the GSO packets without segmentation.

    \item [tx_gso_bytes_noseg]
        The bytes of the GSO packets without segmentation.

\end{description}

\subparagraph{Receiveq Speed Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Receiveq Speed Statistics}

The structure corresponding to the receiveq speed statistics is
\field{struct virtio_net_stats_rx_speed}. The corresponding type is
VIRTIO_NET_STATS_TYPE_RX_SPEED. This is for the receiveq.

The device has the allowance for the speed. If VIRTIO_NET_F_SPEED_DUPLEX has
been negotiated, the driver can get this by \field{speed}. When the received
packets bitrate exceeds the \field{speed}, some packets may be dropped by the
device.

\begin{lstlisting}
struct virtio_net_stats_rx_speed {
    struct virtio_net_stats_reply_hdr hdr;

    le64 rx_packets_allowance_exceeded;
    le64 rx_bytes_allowance_exceeded;
};
\end{lstlisting}

The packets described below were all presented on the specified virtqueue.
\begin{description}
    \item [rx_packets_allowance_exceeded]
        The number of the packets dropped by the device due to the received
        packets bitrate exceeding the \field{speed}.

    \item [rx_bytes_allowance_exceeded]
        The bytes of the packets dropped by the device due to the received
        packets bitrate exceeding the \field{speed}.

\end{description}

\subparagraph{Transmitq Speed Statistics}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics / Transmitq Speed Statistics}

The structure corresponding to the transmitq speed statistics is
\field{struct virtio_net_stats_tx_speed}. The corresponding type is
VIRTIO_NET_STATS_TYPE_TX_SPEED. This is for the transmitq.

The device has the allowance for the speed. If VIRTIO_NET_F_SPEED_DUPLEX has
been negotiated, the driver can get this by \field{speed}. When the transmit
packets bitrate exceeds the \field{speed}, some packets may be dropped by the
device.

\begin{lstlisting}
struct virtio_net_stats_tx_speed {
    struct virtio_net_stats_reply_hdr hdr;

    le64 tx_packets_allowance_exceeded;
    le64 tx_bytes_allowance_exceeded;
};
\end{lstlisting}

The packets described below were all presented on the specified virtqueue.
\begin{description}
    \item [tx_packets_allowance_exceeded]
        The number of the packets dropped by the device due to the transmit packets
        bitrate exceeding the \field{speed}.

    \item [tx_bytes_allowance_exceeded]
        The bytes of the packets dropped by the device due to the transmit packets
        bitrate exceeding the \field{speed}.

\end{description}

\devicenormative{\subparagraph}{Device Statistics}{Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics}

When the VIRTIO_NET_F_DEVICE_STATS feature is negotiated, the device MUST reply
to the command VIRTIO_NET_CTRL_STATS_QUERY with the
\field{struct virtio_net_stats_capabilities}. \field{supported_stats_types}
includes all the statistic types supported by the device.

If \field{struct virtio_net_ctrl_queue_stats} is incorrect (such as the
following), the device MUST set \field{ack} to VIRTIO_NET_ERR. Even if there is
only one error, the device MUST fail the entire command.
\begin{itemize}
    \item \field{vq_index} exceeds the queue range.
    \item \field{types_bitmap} contains unknown types.
    \item One or more of the bits present in \field{types_bitmap} is not valid
        for the specified virtqueue.
    \item The feature corresponding to the specified \field{types_bitmap} was
        not negotiated.
\end{itemize}

The device MUST set the actual size of the bytes occupied by the reply to the
\field{size} of the \field{hdr}. And the device MUST set the \field{type} and
the \field{vq_index} of the statistic header.

The \field{command-specific-result} buffer allocated by the driver may be
smaller or bigger than all the statistics specified by
\field{struct virtio_net_ctrl_queue_stats}. The device MUST fill up only upto
the valid bytes.

The statistics counter replied by the device MUST wrap around to zero by the
device on the overflow.

\drivernormative{\subparagraph}{Device Statistics}{Device Types / Network Device / Device Operation / Control Virtqueue / Device Statistics}

The types contained in the \field{types_bitmap} MUST be queried from the device
via command VIRTIO_NET_CTRL_STATS_QUERY.

\field{types_bitmap} in \field{struct virtio_net_ctrl_queue_stats} MUST be valid to the
vq specified by \field{vq_index}.

The \field{command-specific-result} buffer allocated by the driver MUST have
enough capacity to store all the statistics reply headers defined in
\field{struct virtio_net_ctrl_queue_stats}. If the
\field{command-specific-result} buffer is fully utilized by the device but some
replies are missed, it is possible that some statistics may exceed the capacity
of the driver's records. In such cases, the driver should allocate additional
space for the \field{command-specific-result} buffer.

\subsubsection{Flow filter}\label{sec:Device Types / Network Device / Device Operation / Flow filter}

A network device can support one or more flow filter rules. Each flow filter rule
is applied by matching a packet and then taking an action, such as directing the packet
to a specific receiveq or dropping the packet. An example of a match is
matching on specific source and destination IP addresses.

A flow filter rule is a device resource object that consists of a key,
a processing priority, and an action to either direct a packet to a
receive queue or drop the packet.

Each rule uses a classifier. The key is matched against the packet using
a classifier, defining which fields in the packet are matched.
A classifier resource object consists of one or more field selectors, each with
a type that specifies the header fields to be matched against, and a mask.
The mask can match whole fields or parts of a field in a header. Each
rule resource object depends on the classifier resource object.

When a packet is received, relevant fields are extracted
(in the same way) from both the packet and the key according to the
classifier. The resulting field contents are then compared -
if they are identical the rule action is taken, if they are not, the rule is ignored.

Multiple flow filter rules are part of a group. The rule resource object
depends on the group. Each rule within a
group has a rule priority, and each group also has a group priority. For a
packet, a group with the highest priority is selected first. Within a group,
rules are applied from highest to lowest priority, until one of the rules
matches the packet and an action is taken. If all the rules within a group
are ignored, the group with the next highest priority is selected, and so on.

The device and the driver indicates flow filter resource limits using the capability
\ref{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-RESOURCE-CAP} specifying the limits on the number of flow filter rule,
group and classifier resource objects. The capability \ref{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP} specifies which selectors the device supports.
The driver indicates the selectors it is using by setting the flow
filter selector capability, prior to adding any resource objects.

The capability \ref{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-ACTION-CAP} specifies which actions the device supports.

The driver controls the flow filter rule, classifier and group resource objects using
administration commands described in
\ref{sec:Basic Facilities of a Virtio Device / Device groups / Group administration commands / Device resource objects}.

\paragraph{Packet processing order}\label{sec:sec:Device Types / Network Device / Device Operation / Flow filter / Packet processing order}

Note that flow filter rules are applied after MAC/VLAN filtering. Flow filter
rules take precedence over steering: if a flow filter rule results in an action,
the steering configuration does not apply. The steering configuration only applies
to packets for which no flow filter rule action was performed. For example,
incoming packets can be processed in the following order:

\begin{itemize}
\item apply steering configuration received using control virtqueue commands
      VIRTIO_NET_CTRL_RX, VIRTIO_NET_CTRL_MAC and VIRTIO_NET_CTRL_VLAN.
\item apply flow filter rules if any.
\item if no filter rule applied, apply steering configuration received using command
      VIRTIO_NET_CTRL_MQ_RSS_CONFIG or as per automatic receive steering.
\end{itemize}

Some incoming packet processing examples:
\begin{itemize}
\item If the packet is dropped by the flow filter rule, RSS
      steering is ignored for the packet.
\item If the packet is directed to a specific receiveq using flow filter rule,
      the RSS steering is ignored for the packet.
\item If a packet is dropped due to the VIRTIO_NET_CTRL_MAC configuration,
      both flow filter rules and the RSS steering are ignored for the packet.
\item If a packet does not match any flow filter rules,
      the RSS steering is used to select the receiveq for the packet (if enabled).
\item If there are two flow filter groups configured as group_A and group_B
      with respective group priorities as 4, and 5; flow filter rules of
      group_B are applied first having highest group priority, if there is a match,
      the flow filter rules of group_A are ignored; if there is no match for
      the flow filter rules in group_B, the flow filter rules of next level group_A are applied.
\end{itemize}

\paragraph{Device and driver capabilities}
\label{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities}

\subparagraph{VIRTIO_NET_FF_RESOURCE_CAP}
\label{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-RESOURCE-CAP}

The capability VIRTIO_NET_FF_RESOURCE_CAP indicates the flow filter resource limits.
\field{cap_specific_data} is in the format
\field{struct virtio_net_ff_cap_data}.

\begin{lstlisting}
struct virtio_net_ff_cap_data {
        le32 groups_limit;
        le32 selectors_limit;
        le32 rules_limit;
        le32 rules_per_group_limit;
        u8 last_rule_priority;
        u8 selectors_per_classifier_limit;
};
\end{lstlisting}

\field{groups_limit}, and \field{selectors_limit} represent the maximum
number of flow filter groups and selectors, respectively, that the driver can create.
 \field{rules_limit} is the maximum number of
flow fiilter rules that the driver can create across all the groups.
\field{rules_per_group_limit} is the maximum number of flow filter rules that the driver
can create for each flow filter group.

\field{last_rule_priority} is the highest priority that can be assigned to a
flow filter rule.

\field{selectors_per_classifier_limit} is the maximum number of selectors
that a classifier can have.

\subparagraph{VIRTIO_NET_FF_SELECTOR_CAP}
\label{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP}

The capability VIRTIO_NET_FF_SELECTOR_CAP lists the supported selectors and the
supported packet header fields for each selector.
\field{cap_specific_data} is in the format \field{struct virtio_net_ff_cap_mask_data}.

\begin{lstlisting}[label={lst:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP / virtio-net-ff-selector}]
struct virtio_net_ff_selector {
        u8 type;
        u8 flags;
        u8 reserved[2];
        u8 length;
        u8 reserved1[3];
        u8 mask[];
};

struct virtio_net_ff_cap_mask_data {
        u8 count;
        u8 reserved[7];
        struct virtio_net_ff_selector selectors[];
};

#define VIRTIO_NET_FF_MASK_F_PARTIAL_MASK (1 << 0)
\end{lstlisting}

\field{count} indicates number of valid entries in the \field{selectors} array.
\field{selectors[]} is an array of supported selectors. Within each array entry:
\field{type} specifies the type of the packet header, as defined in table
\ref{table:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP / flow filter selector types}. \field{mask} specifies which fields of the
packet header can be matched in a flow filter rule.

Each \field{type} is also listed in table
\ref{table:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP / flow filter selector types}. \field{mask} is a byte array
in network byte order. For example, when \field{type} is VIRTIO_NET_FF_MASK_TYPE_IPV6,
the \field{mask} is in the format \hyperref[intro:IPv6-Header-Format]{IPv6 Header Format}.

If partial masking is not set, then all bits in each field have to be either all 0s
to ignore this field or all 1s to match on this field. If partial masking is set,
then any combination of bits can bit set to match on these bits.
For example, when a selector \field{type} is VIRTIO_NET_FF_MASK_TYPE_ETH, if
\field{mask[0-12]} are zero and \field{mask[13-14]} are 0xff (all 1s), it
indicates that matching is only supported for \field{EtherType} of
\field{Ethernet MAC frame}, matching is not supported for
\field{Destination Address} and \field{Source Address}.

The entries in the array \field{selectors} are ordered by
\field{type}, with each \field{type} value only appearing once.

\field{length} is the length of a dynamic array \field{mask} in bytes.
\field{reserved} and \field{reserved1} are reserved and set to zero.

\begin{table}[H]
\caption{Flow filter selector types}
\label{table:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP / flow filter selector types}
\begin{tabularx}{\textwidth}{ |l|X|X| }
\hline
Type & Name & Description \\
\hline \hline
0x0 & - & Reserved \\
\hline
0x1 & VIRTIO_NET_FF_MASK_TYPE_ETH & 14 bytes of frame header starting from destination address described in \hyperref[intro:IEEE 802.3-2022]{IEEE 802.3-2022} \\
\hline
0x2 & VIRTIO_NET_FF_MASK_TYPE_IPV4 & 20 bytes of \hyperref[intro:Internet-Header-Format]{IPv4: Internet Header Format} \\
\hline
0x3 & VIRTIO_NET_FF_MASK_TYPE_IPV6 & 40 bytes of \hyperref[intro:IPv6-Header-Format]{IPv6 Header Format} \\
\hline
0x4 & VIRTIO_NET_FF_MASK_TYPE_TCP & 20 bytes of \hyperref[intro:TCP-Header-Format]{TCP Header Format} \\
\hline
0x5 & VIRTIO_NET_FF_MASK_TYPE_UDP & 8 bytes of UDP header described in \hyperref[intro:UDP]{UDP} \\
\hline
0x6 - 0xFF & & Reserved for future \\
\hline
\end{tabularx}
\end{table}

When VIRTIO_NET_FF_MASK_F_PARTIAL_MASK (bit 0) is set, it indicates that
partial masking is supported for all the fields of the selector identified by \field{type}.

For the selector \field{type} VIRTIO_NET_FF_MASK_TYPE_IPV4, if a partial mask is unsupported,
then matching on an individual bit of \field{Flags} in the
\field{IPv4: Internet Header Format} is unsupported. \field{Flags} has to match as a whole
if it is supported.

For the selector \field{type} VIRTIO_NET_FF_MASK_TYPE_IPV4, \field{mask} includes fields
up to the \field{Destination Address}; that is, \field{Options} and
\field{Padding} are excluded.

For the selector \field{type} VIRTIO_NET_FF_MASK_TYPE_IPV6, the \field{Next Header} field
of the \field{mask} corresponds to the \field{Next Header} in the packet
when \field{IPv6 Extension Headers} are not present. When the packet includes
one or more \field{IPv6 Extension Headers}, the \field{Next Header} field of
the \field{mask} corresponds to the \field{Next Header} of the last
\field{IPv6 Extension Header} in the packet.

For the selector \field{type} VIRTIO_NET_FF_MASK_TYPE_TCP, \field{Control bits}
are treated as individual fields for matching; that is, matching individual
\field{Control bits} does not depend on the partial mask support.

\subparagraph{VIRTIO_NET_FF_ACTION_CAP}
\label{par:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-ACTION-CAP}

The capability VIRTIO_NET_FF_ACTION_CAP lists the supported actions in a rule.
\field{cap_specific_data} is in the format \field{struct virtio_net_ff_cap_actions}.

\begin{lstlisting}
struct virtio_net_ff_actions {
        u8 count;
        u8 reserved[7];
        u8 actions[];
};
\end{lstlisting}

\field{actions} is an array listing all possible actions.
The entries in the array are ordered from the smallest to the largest,
with each supported value appearing exactly once. Each entry can have the
following values:

\begin{table}[H]
\caption{Flow filter rule actions}
\label{table:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-ACTION-CAP / flow filter rule actions}
\begin{tabularx}{\textwidth}{ |l|X|X| }
\hline
Action & Name & Description \\
\hline \hline
0x0 & - & reserved \\
\hline
0x1 & VIRTIO_NET_FF_ACTION_DROP & Matching packet will be dropped by the device \\
\hline
0x2 & VIRTIO_NET_FF_ACTION_DIRECT_RX_VQ & Matching packet will be directed to a receive queue \\
\hline
0x3 - 0xFF & & Reserved for future \\
\hline
\end{tabularx}
\end{table}

\paragraph{Resource objects}
\label{par:Device Types / Network Device / Device Operation / Flow filter / Resource objects}

\subparagraph{VIRTIO_NET_RESOURCE_OBJ_FF_GROUP}\label{par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-GROUP}

A flow filter group contains between 0 and \field{rules_limit} rules, as specified by the
capability VIRTIO_NET_FF_RESOURCE_CAP. For the flow filter group object both
\field{resource_obj_specific_data} and
\field{resource_obj_specific_result} are in the format
\field{struct virtio_net_resource_obj_ff_group}.

\begin{lstlisting}
struct virtio_net_resource_obj_ff_group {
        le16 group_priority;
};
\end{lstlisting}

\field{group_priority} specifies the priority for the group. Each group has a
distinct priority. For each incoming packet, the device tries to apply rules
from groups from higher \field{group_priority} value to lower, until either a
rule matches the packet or all groups have been tried.

\subparagraph{VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER}\label{par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-CLASSIFIER}

A classifier is used to match a flow filter key against a packet. The
classifier defines the desired packet fields to match, and is represented by
the VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER device resource object.

For the flow filter classifier object both \field{resource_obj_specific_data} and
\field{resource_obj_specific_result} are in the format
\field{struct virtio_net_resource_obj_ff_classifier}.

\begin{lstlisting}
struct virtio_net_resource_obj_ff_classifier {
        u8 count;
        u8 reserved[7];
        struct virtio_net_ff_selector selectors[];
};
\end{lstlisting}

A classifier is an array of \field{selectors}. The number of selectors in the
array is indicated by \field{count}. The selector has a type that specifies
the header fields to be matched against, and a mask.
See \ref{lst:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-SELECTOR-CAP / virtio-net-ff-selector}
for details about selectors.

The first selector is always VIRTIO_NET_FF_MASK_TYPE_ETH. When there are multiple
selectors, a second selector can be either VIRTIO_NET_FF_MASK_TYPE_IPV4
or VIRTIO_NET_FF_MASK_TYPE_IPV6. If the third selector exists, the third
selector can be either VIRTIO_NET_FF_MASK_TYPE_UDP or VIRTIO_NET_FF_MASK_TYPE_TCP.
For example, to match a Ethernet IPv6 UDP packet,
\field{selectors[0].type} is set to VIRTIO_NET_FF_MASK_TYPE_ETH, \field{selectors[1].type}
is set to VIRTIO_NET_FF_MASK_TYPE_IPV6 and \field{selectors[2].type} is
set to VIRTIO_NET_FF_MASK_TYPE_UDP; accordingly, \field{selectors[0].mask[0-13]} is
for Ethernet header fields, \field{selectors[1].mask[0-39]} is set for IPV6 header
and \field{selectors[2].mask[0-7]} is set for UDP header.

When there are multiple selectors, the type of the (N+1)\textsuperscript{th} selector
affects the mask of the (N)\textsuperscript{th} selector. If
\field{count} is 2 or more, all the mask bits within \field{selectors[0]}
corresponding to \field{EtherType} of an Ethernet header are set.

If \field{count} is more than 2:
\begin{itemize}
\item if \field{selector[1].type} is, VIRTIO_NET_FF_MASK_TYPE_IPV4, then, all the mask bits within
\field{selector[1]} for \field{Protocol} is set.
\item if \field{selector[1].type} is, VIRTIO_NET_FF_MASK_TYPE_IPV6, then, all the mask bits within
\field{selector[1]} for \field{Next Header} is set.
\end{itemize}

If for a given packet header field, a subset of bits of a field is to be matched,
and if the partial mask is supported, the flow filter
mask object can specify a mask which has fewer bits set than the packet header
field size. For example, a partial mask for the Ethernet header source mac
address can be of 1-bit for multicast detection instead of 48-bits.

\subparagraph{VIRTIO_NET_RESOURCE_OBJ_FF_RULE}\label{par:Device Types / Network Device / Device Operation / Flow filter / Resource objects / VIRTIO-NET-RESOURCE-OBJ-FF-RULE}

Each flow filter rule resource object comprises a key, a priority, and an action.
For the flow filter rule object,
\field{resource_obj_specific_data} and
\field{resource_obj_specific_result} are in the format
\field{struct virtio_net_resource_obj_ff_rule}.

\begin{lstlisting}
struct virtio_net_resource_obj_ff_rule {
        le32 group_id;
        le32 classifier_id;
        u8 rule_priority;
        u8 key_length; /* length of key in bytes */
        u8 action;
        u8 reserved;
        le16 vq_index;
        u8 reserved1[2];
        u8 keys[][];
};
\end{lstlisting}

\field{group_id} is the resource object ID of the flow filter group to which
this rule belongs. \field{classifier_id} is the resource object ID of the
classifier used to match a packet against the \field{key}.

\field{rule_priority} denotes the priority of the rule within the group
specified by the \field{group_id}.
Rules within the group are applied from the highest to the lowest priority
until a rule matches the packet and an
action is taken. Rules with the same priority can be applied in any order.

\field{reserved} and \field{reserved1} are reserved and set to 0.

\field{keys[][]} is an array of keys to match against packets, using
the classifier specified by \field{classifier_id}. Each entry (key) comprises
a byte array, and they are located one immediately after another.
The size (number of entries) of the array is exactly the same as that of
\field{selectors} in the classifier, or in other words, \field{count}
in the classifier.

\field{key_length} specifies the total length of \field{keys} in bytes.
In other words, it equals the sum total of \field{length} of all
selectors in \field{selectors} in the classifier specified by
\field{classifier_id}.

For example, if a classifier object's \field{selectors[0].type} is
VIRTIO_NET_FF_MASK_TYPE_ETH and \field{selectors[1].type} is
VIRTIO_NET_FF_MASK_TYPE_IPV6,
then selectors[0].length is 14 and selectors[1].length is 40.
Accordingly, the \field{key_length} is set to 54.
This setting indicates that the \field{key} array's length is 54 bytes
comprising a first byte array of 14 bytes for the
Ethernet MAC header in bytes 0-13, immediately followed by 40 bytes for the
IPv6 header in bytes 14-53.

When there are multiple selectors in the classifier object, the key bytes
for (N)\textsuperscript{th} selector are set so that
(N+1)\textsuperscript{th} selector can be matched.

If \field{count} is 2 or more, key bytes of \field{EtherType}
are set according to \hyperref[intro:IEEE 802 Ethertypes]{IEEE 802 Ethertypes}
for VIRTIO_NET_FF_MASK_TYPE_IPV4 or VIRTIO_NET_FF_MASK_TYPE_IPV6 respectively.

If \field{count} is more than 2, when \field{selector[1].type} is
VIRTIO_NET_FF_MASK_TYPE_IPV4 or VIRTIO_NET_FF_MASK_TYPE_IPV6, key
bytes of \field{Protocol} or \field{Next Header} is set as per
\field{Protocol Numbers} defined \hyperref[intro:IANA Protocol Numbers]{IANA Protocol Numbers}
respectively.

\field{action} is the action to take when a packet matches the
\field{key} using the \field{classifier_id}. Supported actions are described in
\ref{table:Device Types / Network Device / Device Operation / Flow filter / Device and driver capabilities / VIRTIO-NET-FF-ACTION-CAP / flow filter rule actions}.

\field{vq_index} specifies a receive virtqueue. When the \field{action} is set
to VIRTIO_NET_FF_ACTION_DIRECT_RX_VQ, and the packet matches the \field{key},
the matching packet is directed to this virtqueue.

Note that at most one action is ever taken for a given packet. If a rule is
applied and an action is taken, the action of other rules is not taken.

\devicenormative{\paragraph}{Flow filter}{Device Types / Network Device / Device Operation / Flow filter}

When the device supports flow filter operations,
\begin{itemize}
\item the device MUST set VIRTIO_NET_FF_RESOURCE_CAP, VIRTIO_NET_FF_SELECTOR_CAP
and VIRTIO_NET_FF_ACTION_CAP capability in the \field{supported_caps} in the
command VIRTIO_ADMIN_CMD_CAP_SUPPORT_QUERY.
\item the device MUST support the administration commands
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE,
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_MODIFY, VIRTIO_ADMIN_CMD_RESOURCE_OBJ_QUERY,
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY for the resource types
VIRTIO_NET_RESOURCE_OBJ_FF_GROUP, VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER and
VIRTIO_NET_RESOURCE_OBJ_FF_RULE.
\end{itemize}

When any of the VIRTIO_NET_FF_RESOURCE_CAP, VIRTIO_NET_FF_SELECTOR_CAP, or
VIRTIO_NET_FF_ACTION_CAP capability is disabled, the device SHOULD set
\field{status} to VIRTIO_ADMIN_STATUS_Q_INVALID_OPCODE for the commands
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE,
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_MODIFY, VIRTIO_ADMIN_CMD_RESOURCE_OBJ_QUERY,
and VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY. These commands apply to the resource
\field{type} of VIRTIO_NET_RESOURCE_OBJ_FF_GROUP, VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER, and
VIRTIO_NET_RESOURCE_OBJ_FF_RULE.

The device SHOULD set \field{status} to VIRTIO_ADMIN_STATUS_EINVAL for the
command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE when the resource \field{type}
is VIRTIO_NET_RESOURCE_OBJ_FF_GROUP, if a flow filter group already exists
with the supplied \field{group_priority}.

The device SHOULD set \field{status} to VIRTIO_ADMIN_STATUS_ENOSPC for the
command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE when the resource \field{type}
is VIRTIO_NET_RESOURCE_OBJ_FF_GROUP, if the number of flow filter group
objects in the device exceeds the lower of the configured driver
capabilities \field{groups_limit} and \field{rules_per_group_limit}.

The device SHOULD set \field{status} to VIRTIO_ADMIN_STATUS_ENOSPC for the
command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE when the resource \field{type} is
VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER, if the number of flow filter selector
objects in the device exceeds the configured driver capability
\field{selectors_limit}.

The device SHOULD set \field{status} to VIRTIO_ADMIN_STATUS_EBUSY for the
command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY for a flow filter group when
the flow filter group has one or more flow filter rules depending on it.

The device SHOULD set \field{status} to VIRTIO_ADMIN_STATUS_EBUSY for the
command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY for a flow filter classifier when
the flow filter classifier has one or more flow filter rules depending on it.

The device SHOULD fail the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE for the
flow filter rule resource object if,
\begin{itemize}
\item \field{vq_index} is not a valid receive virtqueue index for
the VIRTIO_NET_FF_ACTION_DIRECT_RX_VQ action,
\item \field{priority} is greater than or equal to
      \field{last_rule_priority},
\item \field{id} is greater than or equal to \field{rules_limit} or
      greater than or equal to \field{rules_per_group_limit}, whichever is lower,
\item the length of \field{keys} and the length of all the mask bytes of
      \field{selectors[].mask} as referred by \field{classifier_id} differs,
\item the supplied \field{action} is not supported in the capability VIRTIO_NET_FF_ACTION_CAP.
\end{itemize}

When the flow filter directs a packet to the virtqueue identified by
\field{vq_index} and if the receive virtqueue is reset, the device
MUST drop such packets.

Upon applying a flow filter rule to a packet, the device MUST STOP any further
application of rules and cease applying any other steering configurations.

For multiple flow filter groups, the device MUST apply the rules from
the group with the highest priority. If any rule from this group is applied,
the device MUST ignore the remaining groups. If none of the rules from the
highest priority group match, the device MUST apply the rules from
the group with the next highest priority, until either a rule matches or
all groups have been attempted.

The device MUST apply the rules within the group from the highest to the
lowest priority until a rule matches the packet, and the device MUST take
the action. If an action is taken, the device MUST not take any other
action for this packet.

The device MAY apply the rules with the same \field{rule_priority} in any
order within the group.

The device MUST process incoming packets in the following order:
\begin{itemize}
\item apply the steering configuration received using control virtqueue
      commands VIRTIO_NET_CTRL_RX, VIRTIO_NET_CTRL_MAC, and
      VIRTIO_NET_CTRL_VLAN.
\item apply flow filter rules if any.
\item if no filter rule is applied, apply the steering configuration
      received using the command VIRTIO_NET_CTRL_MQ_RSS_CONFIG
      or according to automatic receive steering.
\end{itemize}

When processing an incoming packet, if the packet is dropped at any stage, the device
MUST skip further processing.

When the device drops the packet due to the configuration done using the control
virtqueue commands VIRTIO_NET_CTRL_RX or VIRTIO_NET_CTRL_MAC or VIRTIO_NET_CTRL_VLAN,
the device MUST skip flow filter rules for this packet.

When the device performs flow filter match operations and if the operation
result did not have any match in all the groups, the receive packet processing
continues to next level, i.e. to apply configuration done using
VIRTIO_NET_CTRL_MQ_RSS_CONFIG command.

The device MUST support the creation of flow filter classifier objects
using the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE with \field{flags}
set to VIRTIO_NET_FF_MASK_F_PARTIAL_MASK;
this support is required even if all the bits of the masks are set for
a field in \field{selectors}, provided that partial masking is supported
for the selectors.

\drivernormative{\paragraph}{Flow filter}{Device Types / Network Device / Device Operation / Flow filter}

The driver MUST enable VIRTIO_NET_FF_RESOURCE_CAP, VIRTIO_NET_FF_SELECTOR_CAP,
and VIRTIO_NET_FF_ACTION_CAP capabilities to use flow filter.

The driver SHOULD NOT remove a flow filter group using the command
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY when one or more flow filter rules
depend on that group. The driver SHOULD only destroy the group after
all the associated rules have been destroyed.

The driver SHOULD NOT remove a flow filter classifier using the command
VIRTIO_ADMIN_CMD_RESOURCE_OBJ_DESTROY when one or more flow filter rules
depend on the classifier. The driver SHOULD only destroy the classifier
after all the associated rules have been destroyed.

The driver SHOULD NOT add multiple flow filter rules with the same
\field{rule_priority} within a flow filter group, as these rules MAY match
the same packet. The driver SHOULD assign different \field{rule_priority}
values to different flow filter rules if multiple rules may match a single
packet.

For the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE, when creating a resource
of \field{type} VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER, the driver MUST set:
\begin{itemize}
\item \field{selectors[0].type} to VIRTIO_NET_FF_MASK_TYPE_ETH.
\item \field{selectors[1].type} to VIRTIO_NET_FF_MASK_TYPE_IPV4 or
      VIRTIO_NET_FF_MASK_TYPE_IPV6 when \field{count} is more than 1,
\item \field{selectors[2].type} VIRTIO_NET_FF_MASK_TYPE_UDP or
      VIRTIO_NET_FF_MASK_TYPE_TCP when \field{count} is more than 2.
\end{itemize}

For the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE, when creating a resource
of \field{type} VIRTIO_NET_RESOURCE_OBJ_FF_CLASSIFIER, the driver MUST set:
\begin{itemize}
\item \field{selectors[0].mask} bytes to all 1s for the \field{EtherType}
       when \field{count} is 2 or more.
\item \field{selectors[1].mask} bytes to all 1s for \field{Protocol} or \field{Next Header}
       when \field{selector[1].type} is VIRTIO_NET_FF_MASK_TYPE_IPV4 or VIRTIO_NET_FF_MASK_TYPE_IPV6,
       and when \field{count} is more than 2.
\end{itemize}

For the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE, the resource \field{type}
VIRTIO_NET_RESOURCE_OBJ_FF_RULE, if the corresponding classifier object's
\field{count} is 2 or more, the driver MUST SET the \field{keys} bytes of
\field{EtherType} in accordance with
\hyperref[intro:IEEE 802 Ethertypes]{IEEE 802 Ethertypes}
for either VIRTIO_NET_FF_MASK_TYPE_IPV4 or VIRTIO_NET_FF_MASK_TYPE_IPV6.

For the command VIRTIO_ADMIN_CMD_RESOURCE_OBJ_CREATE, when creating a resource of
\field{type} VIRTIO_NET_RESOURCE_OBJ_FF_RULE, if the corresponding classifier
object's \field{count} is more than 2, and the \field{selector[1].type} is either
VIRTIO_NET_FF_MASK_TYPE_IPV4 or VIRTIO_NET_FF_MASK_TYPE_IPV6, the driver MUST
set the \field{keys} bytes for the \field{Protocol} or \field{Next Header}
according to \hyperref[intro:IANA Protocol Numbers]{IANA Protocol Numbers} respectively.

The driver SHOULD set all the bits for a field in the mask of a selector in both the
capability and the classifier object, unless the VIRTIO_NET_FF_MASK_F_PARTIAL_MASK
is enabled.

\subsubsection{Legacy Interface: Framing Requirements}\label{sec:Device
Types / Network Device / Legacy Interface: Framing Requirements}

When using legacy interfaces, transitional drivers which have not
negotiated VIRTIO_F_ANY_LAYOUT MUST use a single descriptor for the
\field{struct virtio_net_hdr} on both transmit and receive, with the
network data in the following descriptors.

Additionally, when using the control virtqueue (see \ref{sec:Device
Types / Network Device / Device Operation / Control Virtqueue})
, transitional drivers which have not
negotiated VIRTIO_F_ANY_LAYOUT MUST:
\begin{itemize}
\item for all commands, use a single 2-byte descriptor including the first two
fields: \field{class} and \field{command}
\item for all commands except VIRTIO_NET_CTRL_MAC_TABLE_SET
use a single descriptor including command-specific-data
with no padding.
\item for the VIRTIO_NET_CTRL_MAC_TABLE_SET command use exactly
two descriptors including command-specific-data with no padding:
the first of these descriptors MUST include the
virtio_net_ctrl_mac table structure for the unicast addresses with no padding,
the second of these descriptors MUST include the
virtio_net_ctrl_mac table structure for the multicast addresses
with no padding.
\item for all commands, use a single 1-byte descriptor for the
\field{ack} field
\end{itemize}

See \ref{sec:Basic
Facilities of a Virtio Device / Virtqueues / Message Framing}.
